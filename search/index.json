[{"content":"ELF 文件，大名叫 Executable and Linkable Format。\n作为一种文件，那么肯定就需要遵守一定的格式。\n从宏观上看，可以分成四个部分：\n图中的这几个概念，如果不明白的话也没关系，下面我会逐个说明的。\n在 Linux 系统中，一个 ELF 文件主要用来表示 3 种类型的文件：\n1. 可执行文件\n2. 目标文件\n3. 共享文件\n既然可以用来表示 3 种类型的文件，那么在文件中，肯定有一个地方用来区分这 3 种情况。\n在我的头部内容中，就存在一个字段，用来表示：当前这个 ELF 文件，它到底是一个可执行文件？是一个目标文件？还是一个共享库文件？\n另外，既然我可以用来表示 3 种类型的文件，那么就肯定是在 3 种不同的场合下被使用，或者说被不同的家伙来操作我：\n可执行文件：被操作系统中的加载器从硬盘上读取，载入到内存中去执行;\n目标文件：被链接器读取，用来产生一个可执行文件或者共享库文件;\n共享库文件：在动态链接的时候，由 ld-linux.so 来读取;\n就拿链接器和加载器来说吧，这两个家伙的性格是不一样的，它们看我的眼光也是不一样的。\n链接器看ELF文件，看不见 Program header table. 加载器看ELF文件，看不见 section header table, 并将section改个名字叫segment;\n可以理解为：一个 Segment 可能包含一个或者多个 Sections，就像下面这样：\n其实只要掌握到 2 点内容就可以了：\n一个 ELF 文件一共由 4 个部分组成;\n链接器和加载器，它们在使用我的时候，只会使用它们感兴趣的部分;\n还有一点差点忘记给你提个醒了：在 Linux 系统中，会有不同的数据结构来描述上面所说的每部分内容。\n描述 ELF header 的结构体：\n描述 Program header table 的结构体：\n描述 Section header table 的结构体：\nELF header(ELF 头) 头部内容，就相当于是一个总管，它决定了这个完整的 ELF 文件内部的所有信息，比如：\n这是一个 ELF 文件;\n一些基本信息：版本，文件类型，机器类型;\nProgram header table(程序头表)的开始地址，在整个文件的什么地方;\nSection header table(节头表)的开始地址，在整个文件的什么地方;\n为了方便描述，我就把 Sections 和 Segments 全部统一称为 Sections 在一个 ELF 文件中，存在很多个 Sections，这些 Sections 的具体信息，是在 Program header table 或者 Section head table 中进行描述的。\n就拿 Section head table 来举例吧：\n假如一个 ELF 文件中一共存在 4 个 Section: .text、.rodata、.data、.bss，那么在 Section head table 中，将会有 4 个 Entry(条目)来分别描述这 4 个 Section 的具体信息(严格来说，不止 4 个 Entry，因为还存在一些其他辅助的 Sections)，就像下面这样：\n用一个具体的代码示例来描述，看实实在在的字节码。\n程序的功能比较简单：\n// mymath.c int my_add(int a, int b){ return a + b;} // main.c #include \u0026lt;stdio.h\u0026gt;extern int my_add(int a, int b); int main(){ int i = 1; int j = 2; int k = my_add(i, j); printf(\u0026quot;k = %d \\n\u0026quot;, k);} 从刚才的描述中可以知道：动态库文件 libmymath.so, 目标文件 main.o 和 可执行文件 main，它们都是 ELF 文件，只不过属于不同的类型。\n这里就以可执行文件 main 来拆解它！\n首先用指令 readelf -h main 来看一下 main 文件中，ELF header 的信息。\nreadelf 这个工具，可是一个好东西啊！一定要好好的利用它。\n这张图中显示的信息，就是 ELF header 中描述的所有内容了。这个内容与结构体 Elf32_Ehdr 中的成员变量是一一对应的！\n有没有发现图中第 15 行显示的内容：Size of this header: 52 (bytes)。\n也就是说：ELF header 部分的内容，一共是 52 个字节。那么我就把开头的这 52 个字节码给你看一下。\n这回用 od -Ax -t x1 -N 52 main 这个指令来读取 main 中的字节码，简单解释一下其中的几个选项：\n-Ax: 显示地址的时候，用十六进制来表示。如果使用 -Ad，意思就是用十进制来显示地址;\n-t -x1: 显示字节码内容的时候，使用十六进制(x)，每次显示一个字节(1);\n-N 52：只需要读取 52 个字节;\n这 52 个字节的内容，你可以对照上面的结构体中每个字段来解释了。\n首先看一下前 16 个字节。\n在结构体中的第一个成员是 unsigned char e_ident[EI_NIDENT];，EI_NIDENT 的长度是 16，代表了 EL header 中的开始 16 个字节，具体含义如下：\n0 - 15 个字节\n官方文档对于这部分的解释：\n关于大端、小端格式，这个 main 文件中显示的是 1，代表小端格式。啥意思呢，看下面这张图就明白了：\n那么再来看一下大端格式：\n好了，下面我们继续把剩下的 36 个字节(52 - 16 = 32)，也以这样的字节码含义画出来：\n16 - 31 个字节：\n32 - 47 个字节：\n48 - 51 个字节：\n字符串表表项 Entry 在一个 ELF 文件中，存在很多字符串，例如：变量名、Section名称、链接器加入的符号等等，这些字符串的长度都是不固定的，因此用一个固定的结构来表示这些字符串，肯定是不现实的。\n于是，把这些字符串集中起来，统一放在一起，作为一个独立的 Section 来进行管理。\n在文件中的其他地方呢，如果想表示一个字符串，就在这个地方写一个数字索引：表示这个字符串位于字符串统一存储地方的某个偏移位置，经过这样的按图索骥，就可以找到这个具体的字符串了。\n比如说啊，下面这个空间中存储了所有的字符串：\n在程序的其他地方，如果想引用字符串 “hello,world!”，那么就只需要在那个地方标明数字 13 就可以了，表示：这个字符串从偏移 13 个字节处开始。\n那么现在，咱们再回到这个 main 文件中的字符串表，\n在 ELF header 的最后 2 个字节是 0x1C 0x00，它对应结构体中的成员 e_shstrndx，意思是这个 ELF 文件中，字符串表是一个普通的 Section，在这个 Section 中，存储了 ELF 文件中使用到的所有的字符串。\n既然是一个 Section，那么在 Section header table 中，就一定有一个表项 Entry 来描述它，那么是哪一个表项呢？\n这就是 0x1C 0x00 这个表项，也就是第 28 个表项。\n这里，我们还可以用指令 **readelf -S main **来看一下这个 ELF 文件中所有的 Section 信息：\n其中的第 28 个 Section，描述的正是字符串表 Section:\n可以看出来：这个 Section 在 ELF 文件中的偏移地址是 0x0016ed，长度是 0x00010a 个字节。\n下面，我们从 ELF header 的二进制数据中，来推断这信息。\n读取字符串表 Section 的内容\n来演示一下：如何通过 ELF header 中提供的信息，把字符串表这个 Section 给找出来，然后把它的字节码打印出来给各位看官瞧瞧。\n要想打印字符串表 Section 的内容，就必须知道这个 Section 在 ELF 文件中的偏移地址。\n要想知道偏移地址，只能从 Section head table 中第 28 个表项描述信息中获取。\n要想知道第 28 个表项的地址，就必须知道 Section head table 在 ELF 文件中的开始地址，以及每一个表项的大小。\n正好最后这 2 个需求信息，在 ELF header 中都告诉我们了，因此我们倒着推算，就一定能成功。\nELF header 中的第 32 到 35 字节内容是：F8 17 00 00(注意这里的字节序，低位在前)，表示的就是 Section head table 在 ELF 文件中的开始地址(e_shoff)。\n0x000017F8 = 6136，也就是说 Section head table 的开始地址位于 ELF 文件的第 6136 个字节处。\n知道了开始地址，再来算一下第 28 个表项 Entry 的地址。\nELF header 中的第 46、47 字节内容是：28 00，表示每个表项的长度是 0x0028 = 40 个字节。\n注意这里的计算都是从 0 开始的，因此第 28 个表项的开始地址就是：6136 + 28 * 40 = 7256，也就是说用来描述字符串表这个 Section 的表项，位于 ELF 文件的 7256 字节的位置。\n既然知道了这个表项 Entry 的地址，那么就扒开来看一下其中的二进制内容：\n执行指令：od -Ad -t x1 -j 7256 -N 40 main\n其中的 -j 7256 选项，表示跳过前面的 7256 个字节，也就是我们从 main 这个 ELF 文件的 7256 字节处开始读取，一共读 40 个字节。\n这 40 个字节的内容，就对应了 Elf32_Shdr 结构体中的每个成员变量：\n这里主要关注一下上图中标注出来的 4 个字段:\nsh_name: 暂时不告诉你，马上就解释到了;\nsh_type：表示这个 Section 的类型，3 表示这是一个 string table;\nsh_offset: 表示这个 Section，在 ELF 文件中的偏移量。0x000016ed = 5869，意思是字符串表这个 Section 的内容，从 ELF 文件的 5869 个字节处开始;\nsh_size：表示这个 Section 的长度。0x0000010a = 266 个字节，意思是字符串表这个 Section 的内容，一共有 266 个字节。\n还记得刚才我们使用 readelf 工具，读取到字符串表 Section 在 ELF 文件中的偏移地址是 0x0016ed，长度是 0x00010a 个字节吗？\n与我们这里的推断是完全一致的！\n既然知道了字符串表这个 Section 在 ELF 文件中的偏移量以及长度，那么就可以把它的字节码内容读取出来。\n执行指令:** od -Ad -t c -j 5869 -N 266 main**，所有这些参数应该不用再解释了吧？！\n看一看，瞧一瞧，是不是这个 Section 中存储的全部是字符串？\n刚才没有解释 sh_name 这个字段，它表示字符串表这个 Section 本身的名字，既然是名字，那一定是个字符串。\n但是这个字符串不是直接存储在这里的，而是存储了一个索引，索引值是 0x00000011，也就是十进制数值 17。\n现在我们来数一下字符串表 Section 内容中，第 17 个字节开始的地方，存储的是什么？\n不要偷懒，数一下，是不是看到了：“.shstrtab” 这个字符串(\\0是字符串的分隔符)？！\n读取代码段的内容 从下面的这张图(指令：readelf -S main)：\n可以看到代码段是位于第 14 个表项中，加载(虚拟)地址是 0x08048470，它位于 ELF 文件中的偏移量是 0x000470，长度是 0x0001b2 个字节。\n那我们就来试着读一下其中的内容。\n首先计算这个表项 Entry 的地址：6136 + 14 * 40 = 6696。\n然后读取这个表项 Entry，读取指令是 od -Ad -t x1 -j 6696 -N 40 main:\n同样的，我们也只关心下面这 5 个字段内容：\nsh_name: 这回应该清楚了，表示代码段的名称在字符串表 Section 中的偏移位置。0x9B = 155 字节，也就是在字符串表 Section 的第 155 字节处，存储的就是代码段的名字。回过头去找一下，看一下是不是字符串 “.text”;\nsh_type：表示这个 Section 的类型，1(SHT_PROGBITS) 表示这是代码;\nsh_addr：表示这个 Section 加载的虚拟地址是 0x08048470，这个值与 ELF header 中的 e_entry 字段的值是相同的;\nsh_offset: 表示这个 Section，在 ELF 文件中的偏移量。0x00000470 = 1136，意思是这个 Section 的内容，从 ELF 文件的 1136 个字节处开始;\nsh_size：表示这个 Section 的长度。0x000001b2 = 434 个字节，意思是代码段一共有 434 个字节。\n以上这些分析结构，与指令 readelf -S main 读取出来的完全一样！\nPS: 在查看字符串表 Section 中的字符串时，计算一下：字符串表的开始地址是 5869(十进制)，加上 155，结果就是 6024，所以从 6024 开始的地方，就是代码段的名称，也就是 “.text”。\n知道了以上这些信息，我们就可以读取代码段的字节码了.使用指令：od -Ad -t x1 -j 1136 -N 434 main 即可。\n内容全部是黑乎乎的的字节码，我就不贴出来了。\nProgram header 文章的开头，我就介绍了：我是一个通用的文件结构，链接器和加载器在看待我的时候，眼光是不同的。\n为了对 Program header 有更感性的认识，我还是先用 readelf 这个工具来从总体上看一下 main 文件中的所有段信息。\n执行指令：readelf -l main，得到下面这张图：\n显示的信息已经很明白了:\n这是一个可执行程序;\n入口地址是 0x8048470;\n一共有 9 个 Program header，是从 ELF 文件的 52 个偏移地址开始的;\n布局如下图所示：\n从图中还可以看到，一共有 2 个 LOAD 类型的段:\n我们来读取第一个 LOAD 类型的段，当然还是扒开其中的二进制字节码。\n第一步的工作是，计算这个段表项的地址信息。\n从 ELF header 中得知如下信息：\n字段 e_phoff ：Program header table 位于 ELF 文件偏移 52 个字节的地方。\n字段 e_phentsize: 每一个表项的长度是 32 个字节;\n字段 e_phnum: 一共有 9 个表项 Entry;\n通过计算，得到可读、可执行的 LOAD 段，位于偏移量 116 字节处。\n执行读取指令：od -Ad -t x1 -j 116 -N 32 main：\n按照上面的惯例，我还是把其中几个需要关注的字段，与数据结构中的成员变量进行关联一下：\np_type: 段的类型，1: 表示这个段需要加载到内存中;\np_offset: 段在 ELF 文件中的偏移地址，这里值为 0，表示这个段从 ELF 文件的头部开始;\np_vaddr：段加载到内存中的虚拟地址 0x08048000;\np_paddr：段加载的物理地址，与虚拟地址相同;\np_filesz: 这个段在 ELF 文件中，占据的字节数，0x0744 = 1860 个字节;\np_memsz：这个段加载到内存中，需要占据的字节数，0x0744= 1860 个字节。注意：有些段是不需要加载到内存中的;\n经过上述分析，我们就知道：从 ELF 文件的第 1 到 第 1860 个字节，都是属于这个 LOAD 段的内容。\n在被执行时，这个段需要被加载到内存中虚拟地址为 0x08048000 这个地方，从这里开始，又是一个全新的故事了。\n再回顾一下\n其实只要抓住下面 2 个重点即可：\nELF header 描述了文件的总体信息，以及两个 table 的相关信息(偏移地址，表项个数，表项长度);\n每一个 table 中，包括很多个表项 Entry，每一个表项都描述了一个 Section/Segment 的具体信息。\n链接器和加载器也都是按照这样的原理来解析 ELF 文件的，明白了这些道理，后面在学习具体的链接、加载过程时，就不会迷路啦！\n1 简介 可执行与可链接格式 （Executable and Linkable Format，ELF），常被称为 ELF格式，是一种用于可执行文件、目标代码、共享库和核心转储（core dump）的标准文件格式，一般用于类Unix系统，比如Linux，Macox等。ELF 格式灵活性高、可扩展，并且跨平台。比如它支持不同的字节序和地址范围，所以它不会不兼容某一特别的 CPU 或指令架构。这也使得 ELF 格式能够被运行于众多不同平台的各种操作系统所广泛采纳。\nELF文件一般由三种类型的文件：\n可重定向文件：文件保存着代码和适当的数据，用来和其他的目标文件一起来创建一个可执行文件或者是一个共享目标文件。比如编译的中间产物.o文件； 可执行文件：一个可执行文件； 共享目标文件：共享库。文件保存着代码和合适的数据，用来被下连接编辑器和动态链接器链接。比如linux下的.so文件。 2 ELF文件格式 在编译过程中ELF文件格式在链接和程序的运行阶段的格式不同。链接阶段每个.o文件都是一个独立的ELF文件，为了效率和便利性他们的段需要进行合并才能生成对应的可执行文件。\nELF文件包含一个Header描述文件的基本信息；程序头表告诉徐彤如何构建进程的内存镜像，因此只有可执行文件由程序头表；Sections描述了链接过程中的需要的符号表、数据、指令等信息，而在可执行文件中是Segments，是经过合并的Secitons；节/段头表指明了对应section/segment在文件中的偏移，链接阶段的ELF文件必须包含该表头；而每个节/段头描述了对应的section/segment的大小，入口等基本信息。\n下图是32bit系统下面使用的字段的数大小，64bit系统类似，之后不在赘述。\n2.1 ELF Header ELF文件头描述了ELF文件的基本类型，地址偏移等信息，分为32bit和64bit两个版本，定义于linux源码的/usr/include/elf.h文件中。\n#define EI_NIDENT\t16 typedef struct elf32_hdr{ unsigned char\te_ident[EI_NIDENT]; Elf32_Half\te_type; Elf32_Half\te_machine; Elf32_Word\te_version; Elf32_Addr\te_entry; /* Entry point */ Elf32_Off\te_phoff; Elf32_Off\te_shoff; Elf32_Word\te_flags; Elf32_Half\te_ehsize; Elf32_Half\te_phentsize; Elf32_Half\te_phnum; Elf32_Half\te_shentsize; Elf32_Half\te_shnum; Elf32_Half\te_shstrndx; } Elf32_Ehdr; typedef struct elf64_hdr { unsigned char\te_ident[EI_NIDENT];\t/* ELF \u0026quot;magic number\u0026quot; */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry;\t/* Entry point virtual address */ Elf64_Off e_phoff;\t/* Program header table file offset */ Elf64_Off e_shoff;\t/* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx; } Elf64_Ehdr; 从上面的结构中能够看出32bit和64bit的区别仅仅是字长的区别，字段上没有实际上的差别。每个字段的含义如下：\ne_ident：ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式，位数等： [0,3]字节为魔数，即e_ident[EI_MAG0-EI_MAG3]，取值为固定的0x7f E L F，标记当前文件为一个ELF文件； [4,4]字节为EI_CLASS即e_ident[EI_CLASS]，表明当前文件的类别： 0：表示非法的类别； 1：表示32bit； 2：表示64bit； [5,5]字节为EI_DATA即e_ident[EI_DATA],表明当期那文件的数据排列方式： 0表示非法； 1表示小端； 2表示大端； [6,6]字节为EI_VERSION即e_ident[EI_VERSION]，表明当前文件的版本，目前该取值必须为EV_CURRENT即1； [7,7]字节为EI_PAD即e_ident[EI_PAD]表明e_ident中未使用的字节的起点（值是相对于e_ident[EI_PAD+1]的偏移），未使用的字节会被初始化为0，解析ELF文件时需要忽略对应的字段； EI_MAG0,EI_MAG1,EI_MAG2,EI_MAG3,EI_CLASS,EI_DATA,EI_VERSION，EI_OSABI,EI_PAD是linux源码中定义的宏，取值分别为0-7，分别对应各个字段的下标；下面的宏定义将采用类似EI_MAG0(0)的方式，表示EI_MAG0的值为0。\ne_type：文件的标识字段标识文件的类型； ET_NONE(0)：未知的文件格式； ET_REL(1)：可重定位文件，比如目标文件； ET_EXEC(2)：可执行文件； ET_DYN(3)：共享目标文件； ET_CORE(4)：Core转储文件，比如程序crash之后的转储文件； ET_LOPROC(0xff00)：特定处理器的文件标识； ET_HIPROC(0xffff)：特定处理器的文件标识; [ET_LOPROC,ET_HIPROC]之间的值用来表示特定处理器的文件格式； e_machine：目标文件的体系结构（下面列举了少数处理器架构，具体ELF文件支持的架构在对应的文件中查看即可）； ET_NONE(0)：未知的处理器架构； EM_M32(1)：AT\u0026amp;T WE 32100； EM_SPARC(2)：SPARC； EM_386(3)：Intel 80386； EM_68K(4)：Motorola 68000； EM_88K(5)：Motorola 88000； EM_860(6)：Intel 80860； EM_MIPS(7)：MIPS RS3000大端； EM_MIPS_RS4_BE(10)：MIPS RS4000大端； 其他，预留； e_version：当前文件的版本； EV_NONE(0)：非法的版本； EV_CURRENT(`)：当前版本； e_entry：程序的虚拟入口地址，如果文件没有对应的入口可以为0； e_phoff：文件中程序头表的偏移（bytes），如果文件没有该项，则应该为0； e_shoff：文件中段表/节表的偏移（bytes），如果文件没有该项，则应该为0； e_flags：处理器相关的标志位，宏格式为EF_machine_flag比如EF_MIPS_PIC； e_ehsize：ELF文件头的大小（bytes）； e_phentsize：程序头表中单项的大小，表中每一项的大小相同； e_phnum：程序头表中的项数，也就是说程序头表的实际大小为ephentsize x e_phnum，如果文件中没有程序头表该项为0； e_shentsize：节表中单项的大小，表中每一项的大小相同； e_shnum：节表中项的数量； e_shstrndx：节表中节名的索引，如果文件没有该表则该项为SHN_UNDEF(0)。 2.2 程序头表（Program Header Table） 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。程序头表描述了ELF文件中Segment在文件中的布局，描述了OS该如何装载可执行文件到内存。程序头表的表项的描述如下，类似于ELF Header也有32和64位两个版本。\ntypedef struct elf32_phdr { Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align; } Elf32_Phdr; typedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset;\t/* Segment file offset */ Elf64_Addr p_vaddr;\t/* Segment virtual address */ Elf64_Addr p_paddr;\t/* Segment physical address */ Elf64_Xword p_filesz;\t/* Segment size in file */ Elf64_Xword p_memsz;\t/* Segment size in memory */ Elf64_Xword p_align;\t/* Segment alignment, file \u0026amp; memory */ } Elf64_Phdr; p_type：当前Segment的类型； PT_NULL(0)：当前项未使用，项中的成员是未定义的，需要忽略当前项； PT_LOAD(1)：当前Segment是一个可装载的Segment，即可以被装载映射到内存中，其大小由p_filesz和p_memsz描述。如果p_memsz\u0026gt;p_filesz则剩余的字节被置零，但是p_filesz\u0026gt;p_memsz是非法的。动态库一般包含两个该类型的段：代码段和数据段； PT_DYNAMIC(2)：动态段，动态库特有的段，包含了动态链接必须的一些信息，比如需要链接的共享库列表、GOT等等； PT_INTERP(3)：当前段用于存储一段以NULL为结尾的字符串，该字符串表明了程序解释器的位置。且当前段仅仅对于可执行文件有实际意义，一个可执行文件中不能出现两个当前段，如果一个文件中包含当前段。比如/lib64/ld-linux-x86-64.so.2； PT_NOTE(4)：用于保存与特定供应商或者系统相关的附加信息以便于兼容性、一致性检查，但是实际上只保存了操作系统的规范信息； PT_SHLIB(5)：保留段； PT_PHDR(6)：保存程序头表本身的位置和大小，当前段不能在文件中出现一次以上，且仅仅当程序表头为内存映像的一部分时起作用，它必须在所有加载项目之前； [PT_LPROC(0x70000000),PT_HIPROC(0x7fffffff)]：该范围内的值用作预留； p_offset：当前段相对于文件起始位置的偏移量； p_vaddr：段的第一个字节将被映射到到内存中的虚拟地址； p_paddr：此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的； p_filesz：段在文件映像中所占的字节数，可能为 0； p_memsz：段在内存映像中占用的字节数，可能为 0； p_flags：段相关的标志； p_align：段在文件中和内存中如何对齐。可加载的进程段的p_vaddr和- p_offset取值必须合适，相对于对页面大小的取模而言； 0和1表示不需要对齐； 其他值必须为2的幂次方，且必须 p _ a d d r ∣ p _ a l i g n = = p _ o f f s e t ∣ p a l i g n p\\_addr|p\\_align==p\\_offset| p_align p_addr∣p_align==p_offset∣pa​lign。 2.3 节头表（Section Header Table） 节头表描述了ELF文件中的节的基本信息。可执行文件不一定由节头表但是一定有节，节头表可利用特殊的方式去除。\n段和节的区别是：\n段包含了程序装载可执行的基本信息，段告诉OS如何装载当前段到虚拟内存以及当前段的权限等和执行相关的信息，一个段可以包含0个或多个节； 节包含了程序的代码和数据等内容，链接器会将多个节合并为一个段。 typedef struct elf32_shdr { Elf32_Word\tsh_name; Elf32_Word\tsh_type; Elf32_Word\tsh_flags; Elf32_Addr\tsh_addr; Elf32_Off\tsh_offset; Elf32_Word\tsh_size; Elf32_Word\tsh_link; Elf32_Word\tsh_info; Elf32_Word\tsh_addralign; Elf32_Word\tsh_entsize; } Elf32_Shdr; typedef struct elf64_shdr { Elf64_Word sh_name;\t/* Section name, index in string tbl */ Elf64_Word sh_type;\t/* Type of section */ Elf64_Xword sh_flags;\t/* Miscellaneous section attributes */ Elf64_Addr sh_addr;\t/* Section virtual addr at execution */ Elf64_Off sh_offset;\t/* Section file offset */ Elf64_Xword sh_size;\t/* Size of section in bytes */ Elf64_Word sh_link;\t/* Index of another section */ Elf64_Word sh_info;\t/* Additional section information */ Elf64_Xword sh_addralign;\t/* Section alignment */ Elf64_Xword sh_entsize;\t/* Entry size if section holds table */ } Elf64_Shdr; sh_name：值是节名称在字符串表中的索引； sh_type：描述节的类型和语义； SHT_NULL(0)：当前节是非活跃的，没有一个对应的具体的节内存； SHT_PROGBITS(1)：包含了程序的指令信息、数据等程序运行相关的信息； SHT_SYMTAB(2)：保存了符号信息，用于重定位； 此种类型节的sh_link存储相关字符串表的节索引，sh_info存储最后一个局部符号的符号表索引+1； SHT_DYNSYM(11)：保存共享库导入动态符号信息； 此种类型节的sh_link存储相关字符串表的节索引，sh_info存储最后一个局部符号的符号表索引+1； SHT_STRTAB(3)：一个字符串表，保存了每个节的节名称； SHT_RELA(4)：存储可重定位表项，可能会有附加内容，目标文件可能有多个可重定位表项； 此种类型节的sh_link存储相关符号表的节索引，sh_info存储重定位所使用节的索引； SHT_HASH(5)：存储符号哈希表，所有参与动态链接的目标只能包含一个哈希表，一个目标文件只能包含一个哈希表； 此种类型节的sh_link存储哈希表所使用的符号表的节索引,sh_info为0； SHT_DYAMIC(6)：存储包含动态链接的信息，一个目标文件只能包含一个； 此种类型的节的sh_link存储当前节中使用到的字符串表格的节的索引，sh_info为0； SHT_NOTE(7)：存储以某种形式标记文件的信息； SHT_NOBITS(8)：这种类型的节不占据文件空间，但是成员sh_offset依然会包含对应的偏移； SHT_REL(9)：包含可重定位表项，无附加内容，目标文件可能有多个可重定位表项； 此种类型节的sh_link存储相关符号表的节索引，sh_info存储重定位所使用节的索引； SHT_SHLIB(10)：保留区，包含此节的程序与ABI不兼容； [SHT_LOPROC(0x70000000),SHT_HIPROC(0x7fffffff)]：留给处理器专用语义； [SHT_LOUSER(0x80000000),SHT_HIUSER(0xffffffff)]：预留； sh_flags：1bit位的标志位； SHF_WRITE(0x1)：当前节包含进程执行过程中可写的数据； SHF_ALLOC(0x2)：当前节在运行阶段占据内存； SHF_EXECINSTR(0x4)：当前节包含可执行的机器指令； SHF_MASKPROC(0xf0000000)：所有包含当前掩码都表示预留给特定处理器的； sh_addr：如果当前节需要被装载到内存，则当前项存储当前节映射到内存的首地址，否则应该为0； sh_offset：当前节的首地址相对于文件的偏移； sh_size：节的大小。但是对于类型为SHT_NOBITS的节，当前值可能不为0但是在文件中不占据任何空间； sh_link：存储节投标中的索引，表示当前节依赖于对应的节。对于特定的节有特定的含义，其他为SHN_UNDEF； sh_info：节的附加信息。对于特定的节有特定的含义，其他为0； sh_addralign：地址约束对齐，值应该为0或者2的幂次方，0和1表示未进行对齐； sh_entsize：某些节是一个数组，对于这类节当前字段给出数组中每个项的字节数，比如符号表。如果节并不包含对应的数组，值应该为0。 2.3 一些特殊的节 ELF文件中有一些预定义的节来保存程序、数据和一些控制信息，这些节被用来链接或者装载程序。每个操作系统都支持一组链接模式，主要分为两类（也就是常说的动态库和静态库）：\nStatic：静态绑定的一组目标文件、系统库和库档案（比如静态库），解析包含的符号引用并创建一个完全自包含的可执行文件； Dynamic：一组目标文件、库、系统共享资源和其他共享库链接在一起创建可执行文件。当加载此可执行文件时必须使系统中其他共享资源和动态库可用，程序才能正常运行。 库文件无论是动态库还是静态库在其文件中都包含对应的节，一些特殊的节其功能如下：\n.bss，类型SHT_NOBITS，属性SHF_ALLOC|SHF_WRITE：存储未经初始化的数据。根据定义程序开始执行时，系统会将这些数据初始化为0，且此节不占用文件空间； .comment，类型SHT_PROGBITS，属性none：存储版本控制信息； .data，类型SHT_PROGBITS，属性SHF_ALLOC|SHF_WRITE：存放初始化的数据； .data1，类型SHT_PROGBITS，属性SHF_ALLOC|SHF_WRITE：存放初始化的数据； .debug，类型SHT_PROGBITS，属性none：存放用于符号调试的信息； .dynamic，类型SHT_DYNAMIC，属性SHF_ALLOC，是否有属性SHF_WRITE屈居于处理器：包含动态链接的信息， .hash，类型SHT_HASH，属性SHF_ALLOC： .line，类型SHT_PROGBITS，属性none：存储调试的行号信息，描述源代码和机器码之间的对应关系； .note，类型SHT_NOTE，属性none： .rodata，类型SHT_PROGBITS，属性SHF_ALLOC：存储只读数据； .rodata1，类型SHT_PROGBITS，属性SHF_ALLOC：存储只读数据； .shstrtab，类型SHT_STRTAB，属性none：存储节的名称； .strtab，类型SHT_STRTAB：存储常见的与符号表关联的字符串。如果文件有一个包含符号字符串表的可加载段，则该段的属性将包括 SHF_ALLOC 位； 否则，该位将关闭； .symtab，类型SHT_SYMTAB，属性``````：存储一个符号表。如果文件具有包含符号表的可加载段，则该节的属性将包括 SHF_ALLOC 位；否则，该位将关闭； .text，类型SHT_PROGBITS，属性SHF_ALLOC|SHF_EXECINSTR：存储程序的代码指令； .dynstr，类型SHT_STRTAB，属性SHF_ALLOC：存储动态链接所需的字符串，最常见的是表示与符号表条目关联的名称的字符串； .dynsym，类型SHT_DYNSYM，属性SHF_ALLOC：存储动态链接符号表； .fini，类型SHT_PROGBITS，属性SHF_ALLOC|SHF_EXECINSTR：存储有助于进程终止代码的可执行指令。 当程序正常退出时，系统执行本节代码； .init，类型SHT_PROGBITS，属性SHF_ALLOC|SHF_EXECINSTR：存储有助于进程初始化代码的可执行指令。 当程序开始运行时，系统会在调用主程序入口点（C 程序称为 main）之前执行本节中的代码； .interp，类型SHT_PROGBITS：保存程序解释器的路径名。 如果文件有一个包含该节的可加载段，则该节的属性将包括 SHF_ALLOC 位； 否则，该位将关闭； .relname，类型SHT_REL：包含重定位信息。如果文件具有包含重定位的可加载段，则这些部分的属性将包括 SHF_ALLOC 位；否则，该位将关闭。通常，名称由 重定位适用的部分。因此.text的重定位部分通常具有名称.rel.text或.rela.text； .relaname，类型SHT_RELA：同relname。 其他：对于C++程序有些版本会有.ctors（有时也会是.init_array，见Can’t find .dtors and .ctors in binary）和dtors两个节存储构造和析构相关的代码。 带有点 (.) 前缀的部分名称是为系统保留的，但如果它们的现有含义令人满意，应用程序可以使用这些部分。 应用程序可以使用不带前缀的名称以避免与系统部分冲突。 目标文件格式允许定义不在上面列表中的部分。 一个目标文件可能有多个同名的部分。\n2.4 字符串表 字符串表是一个存储字符串的表格，而每个字符串是以NULL也就是\\0为结尾的。字符串表格中索引为0处的字符串被定义为空字符串。符号表中保存的字符串是节名和目标文件中使用到的符号。而需要使用对应字符串时，只需要在需要使用的地方指明对应字符在字符串表中的索引即可，使用的字符串就是索引处到第一个\\0之间的字符串。\n2.5 符号表 目标文件的符号表包含定位和重定位程序的符号定义和引用所需的信息。符号表索引是该数组的下标。索引0既指定表中的第一个条目，又用作未定义的符号索引。\ntypedef struct elf32_sym{ Elf32_Word\tst_name; Elf32_Addr\tst_value; Elf32_Word\tst_size; unsigned char\tst_info; unsigned char\tst_other; Elf32_Half\tst_shndx; } Elf32_Sym; typedef struct elf64_sym { Elf64_Word st_name;\t/* Symbol name, index in string tbl */ unsigned char\tst_info;\t/* Type and binding attributes */ unsigned char\tst_other;\t/* No defined meaning, 0 */ Elf64_Half st_shndx;\t/* Associated section index */ Elf64_Addr st_value;\t/* Value of the symbol */ Elf64_Xword st_size;\t/* Associated symbol size */ } Elf64_Sym; st_name：存储一个指向字符串表的索引来表示对应符号的名称；\nst_value：存储对应符号的取值，具体值依赖于上下文，可能是一个指针地址，立即数等。另外，不同对象文件类型的符号表条目对 st_value 成员的解释略有不同：\n在重定位文件中在可重定位文件中，st_value保存节索引为SHN_COMMON的符号的对齐约束； 在可重定位文件中，st_value保存已定义符号的节偏移量。 也就是说，st_value是从st_shndx标识的部分的开头的偏移量； 在可执行文件和共享对象文件中，st_value保存一个虚拟地址。 为了使这些文件的符号对动态链接器更有用，节偏移（文件解释）让位于与节号无关的虚拟地址（内存解释）。 st_size：符号的大小，具体指为sizeof(instance)，如果未知则为0；\nst_info：指定符号的类型和绑定属性。可以用下面的代码分别解析出bind,type,info三个属性：\n#define ELF32_ST_BIND(i) ((i)\u0026raquo;4) #define ELF32_ST_TYPE(i) ((i)\u0026amp;0xf) #define ELF32_ST_INFO(b,t) (((b)\u0026laquo;4)+((t)\u0026amp;0xf))\nBIND\nSTB_LOCAL(0)：局部符号在包含其定义的目标文件之外是不可见的。 同名的本地符号可以存在于多个文件中，互不干扰； STB_GLOBAL(1)：全局符号对所有正在组合的目标文件都是可见的。 一个文件对全局符号的定义将满足另一个文件对同一全局符号的未定义引用； STB_WEAK(2)：弱符号类似于全局符号，但它们的定义具有较低的优先级； [STB_LOPROC(13),STB_HIPROC(15)]：预留位，用于特殊处理器的特定含义； TYPE：\nSTT_NOTYPE(0)：符号的类型未指定； STT_OBJECT(1)：符号与数据对象相关联，例如变量、数组等； STT_FUNC(2)：符号与函数或其他可执行代码相关联； STT_SECTION(3)：该符号与一个节相关联。 这种类型的符号表条目主要用于重定位，通常具有STB_LOCALBIND属性； STT_FILE(4)：一个有STB_LOCAL的BIND属性的文件符号的节索引为SHN_ABS。并且如果存在其他STB_LOCAL属性的符号，则当前符号应该在其之前； [STT_LOPROC(13),STT_HIPROC(15)]：预留位，用于特殊处理器的特定含义； INFO：\nSHN_ABS：符号有一个绝对值，不会因为重定位而改变； SHN_COMMON：该符号标记尚未分配的公共块。 符号的值给出了对齐约束，类似于节的 sh_addralign 成员。 也就是说，链接编辑器将为符号分配存储空间，该地址是 st_value 的倍数。 符号的大小表明需要多少字节； SHN_UNDEF：此节表索引表示该符号未定义。 当链接编辑器将此对象文件与另一个定义指定符号的文件组合时，此文件对符号的引用将链接到实际定义； st_other：该成员当前持有 0 并且没有定义的含义；\nst_shndx：每个符号都有属于的节，当前成员存储的就是对应节的索引。\n3 ELF文件示例 下面是使用下面的代码编译生成动态库libadd.so作为示例：\n//add.h int add(int a, int b); static int mult(int a, int b); //add.c //编译命令gcc add.c -shared -o libadd.so extern int extern_value; static int static_value = 1; static int static_value1; int add(int a, int b){ return 0; } static int mult(int a, int b){ return 1; } 3.1 ELF Header 使用命令readelf -h \u0026lt;ELF文件名\u0026gt;查看ELF文件的Header。\n//readelf -h libadd.so ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x4a0 Start of program headers: 64 (bytes into file) Start of section headers: 6000 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 7 Size of section headers: 64 (bytes) Number of section headers: 24 Section header string table index: 23 从上面的Magic Number中能够看出：当前文件类型为64bit的共享库，小端存储，版本为1，机器架构为x86-64，程序头表项有7项，节头表项有24项。\n3.2 Program Header Table 使用命令readelf -l \u0026lt;ELF文件名\u0026gt;查看程序头表；\n//readelf -l libadd.so Elf file type is DYN (Shared object file) Entry point 0x4a0 There are 7 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000674 0x0000000000000674 R E 0x200000 LOAD 0x0000000000000e80 0x0000000000200e80 0x0000000000200e80 0x00000000000001a4 0x00000000000001b0 RW 0x200000 DYNAMIC 0x0000000000000e90 0x0000000000200e90 0x0000000000200e90 0x0000000000000150 0x0000000000000150 RW 0x8 NOTE 0x00000000000001c8 0x00000000000001c8 0x00000000000001c8 0x0000000000000024 0x0000000000000024 R 0x4 GNU_EH_FRAME 0x00000000000005a8 0x00000000000005a8 0x00000000000005a8 0x000000000000002c 0x000000000000002c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000000e80 0x0000000000200e80 0x0000000000200e80 0x0000000000000180 0x0000000000000180 R 0x1 Section to Segment mapping: Segment Sections... 00 .note.gnu.build-id .gnu.hash .dynsym .dynstr .rela.dyn .init .plt .plt.got .text .fini .eh_frame_hdr .eh_frame 01 .init_array .fini_array .dynamic .got .got.plt .data .bss 02 .dynamic 03 .note.gnu.build-id 04 .eh_frame_hdr 05 06 .init_array .fini_array .dynamic .got 从上面看出上半部分的内容基本和程序头表项的每个字段基本对应。从下面的Segment Sections可以看出一个Segment是多个Section的集合。\n3.3 Section Header Table 使用命令readelf -S \u0026lt;ELF文件名\u0026gt;查看节头表的内容。\n➜ tmp readelf -S libadd.so There are 24 section headers, starting at offset 0x1770: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .note.gnu.build-i NOTE 00000000000001c8 000001c8 0000000000000024 0000000000000000 A 0 0 4 [ 2] .gnu.hash GNU_HASH 00000000000001f0 000001f0 000000000000003c 0000000000000000 A 3 0 8 [ 3] .dynsym DYNSYM 0000000000000230 00000230 0000000000000108 0000000000000018 A 4 1 8 [ 4] .dynstr STRTAB 0000000000000338 00000338 000000000000007d 0000000000000000 A 0 0 1 [ 5] .rela.dyn RELA 00000000000003b8 000003b8 00000000000000a8 0000000000000018 A 3 0 8 [ 6] .init PROGBITS 0000000000000460 00000460 0000000000000017 0000000000000000 AX 0 0 4 [ 7] .plt PROGBITS 0000000000000480 00000480 0000000000000010 0000000000000010 AX 0 0 16 [ 8] .plt.got PROGBITS 0000000000000490 00000490 0000000000000008 0000000000000008 AX 0 0 8 [ 9] .text PROGBITS 00000000000004a0 000004a0 00000000000000fc 0000000000000000 AX 0 0 16 [10] .fini PROGBITS 000000000000059c 0000059c 0000000000000009 0000000000000000 AX 0 0 4 [11] .eh_frame_hdr PROGBITS 00000000000005a8 000005a8 000000000000002c 0000000000000000 A 0 0 4 [12] .eh_frame PROGBITS 00000000000005d8 000005d8 000000000000009c 0000000000000000 A 0 0 8 [13] .init_array INIT_ARRAY 0000000000200e80 00000e80 0000000000000008 0000000000000008 WA 0 0 8 [14] .fini_array FINI_ARRAY 0000000000200e88 00000e88 0000000000000008 0000000000000008 WA 0 0 8 [15] .dynamic DYNAMIC 0000000000200e90 00000e90 0000000000000150 0000000000000010 WA 4 0 8 [16] .got PROGBITS 0000000000200fe0 00000fe0 0000000000000020 0000000000000008 WA 0 0 8 [17] .got.plt PROGBITS 0000000000201000 00001000 0000000000000018 0000000000000008 WA 0 0 8 [18] .data PROGBITS 0000000000201018 00001018 000000000000000c 0000000000000000 WA 0 0 8 [19] .bss NOBITS 0000000000201024 00001024 000000000000000c 0000000000000000 WA 0 0 4 [20] .comment PROGBITS 0000000000000000 00001024 0000000000000029 0000000000000001 MS 0 0 1 [21] .symtab SYMTAB 0000000000000000 00001050 00000000000004c8 0000000000000018 22 41 8 [22] .strtab STRTAB 0000000000000000 00001518 0000000000000193 0000000000000000 0 0 1 [23] .shstrtab STRTAB 0000000000000000 000016ab 00000000000000c3 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) 从上面看出内容基本和程序头表项的每个字段基本对应。除了上面提到的特殊的节也有一些额外的节，比如.got.plt。\n3.4 符号表 readelf -s \u0026lt;ELF文件名\u0026gt;查看符号表。\n//readelf -s libadd.so Symbol table '.dynsym' contains 11 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __cxa_finalize 2: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 3: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 4: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 5: 0000000000201024 0 NOTYPE GLOBAL DEFAULT 18 _edata 6: 0000000000201030 0 NOTYPE GLOBAL DEFAULT 19 _end 7: 0000000000000460 0 FUNC GLOBAL DEFAULT 6 _init 8: 000000000000057a 17 FUNC GLOBAL DEFAULT 9 add 9: 0000000000201024 0 NOTYPE GLOBAL DEFAULT 19 __bss_start 10: 000000000000059c 0 FUNC GLOBAL DEFAULT 10 _fini Symbol table '.symtab' contains 51 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000000001c8 0 SECTION LOCAL DEFAULT 1 2: 00000000000001f0 0 SECTION LOCAL DEFAULT 2 3: 0000000000000230 0 SECTION LOCAL DEFAULT 3 4: 0000000000000338 0 SECTION LOCAL DEFAULT 4 5: 00000000000003b8 0 SECTION LOCAL DEFAULT 5 6: 0000000000000460 0 SECTION LOCAL DEFAULT 6 7: 0000000000000480 0 SECTION LOCAL DEFAULT 7 8: 0000000000000490 0 SECTION LOCAL DEFAULT 8 9: 00000000000004a0 0 SECTION LOCAL DEFAULT 9 10: 000000000000059c 0 SECTION LOCAL DEFAULT 10 11: 00000000000005a8 0 SECTION LOCAL DEFAULT 11 12: 00000000000005d8 0 SECTION LOCAL DEFAULT 12 13: 0000000000200e80 0 SECTION LOCAL DEFAULT 13 14: 0000000000200e88 0 SECTION LOCAL DEFAULT 14 15: 0000000000200e90 0 SECTION LOCAL DEFAULT 15 16: 0000000000200fe0 0 SECTION LOCAL DEFAULT 16 17: 0000000000201000 0 SECTION LOCAL DEFAULT 17 18: 0000000000201018 0 SECTION LOCAL DEFAULT 18 19: 0000000000201024 0 SECTION LOCAL DEFAULT 19 20: 0000000000000000 0 SECTION LOCAL DEFAULT 20 21: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 22: 00000000000004a0 0 FUNC LOCAL DEFAULT 9 deregister_tm_clones 23: 00000000000004e0 0 FUNC LOCAL DEFAULT 9 register_tm_clones 24: 0000000000000530 0 FUNC LOCAL DEFAULT 9 __do_global_dtors_aux 25: 0000000000201024 1 OBJECT LOCAL DEFAULT 19 completed.7698 26: 0000000000200e88 0 OBJECT LOCAL DEFAULT 14 __do_global_dtors_aux_fin 27: 0000000000000570 0 FUNC LOCAL DEFAULT 9 frame_dummy 28: 0000000000200e80 0 OBJECT LOCAL DEFAULT 13 __frame_dummy_init_array_ 29: 0000000000000000 0 FILE LOCAL DEFAULT ABS add.c 30: 0000000000201020 4 OBJECT LOCAL DEFAULT 18 static_value 31: 0000000000201028 4 OBJECT LOCAL DEFAULT 19 static_value1 32: 000000000000058b 17 FUNC LOCAL DEFAULT 9 mult 33: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 34: 0000000000000670 0 OBJECT LOCAL DEFAULT 12 __FRAME_END__ 35: 0000000000000000 0 FILE LOCAL DEFAULT ABS 36: 0000000000200e90 0 OBJECT LOCAL DEFAULT 15 _DYNAMIC 37: 0000000000201028 0 OBJECT LOCAL DEFAULT 18 __TMC_END__ 38: 0000000000201018 0 OBJECT LOCAL DEFAULT 18 __dso_handle 39: 00000000000005a8 0 NOTYPE LOCAL DEFAULT 11 __GNU_EH_FRAME_HDR 40: 0000000000201000 0 OBJECT LOCAL DEFAULT 17 _GLOBAL_OFFSET_TABLE_ 41: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __cxa_finalize 42: 0000000000000460 0 FUNC GLOBAL DEFAULT 6 _init 43: 000000000000057a 17 FUNC GLOBAL DEFAULT 9 add 44: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 45: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 46: 0000000000201024 0 NOTYPE GLOBAL DEFAULT 19 __bss_start 47: 000000000000059c 0 FUNC GLOBAL DEFAULT 10 _fini 48: 0000000000201024 0 NOTYPE GLOBAL DEFAULT 18 _edata 49: 0000000000201030 0 NOTYPE GLOBAL DEFAULT 19 _end 50: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 符号表可以看出有两个分别为dynsym和symtab，symtab中包含所有在程序中出现的符号以及一些库函数的符号，而dynsym中的符号是symtab中符号的子集，仅仅出现了外部可以看到的符号（静态函数mult的符号在dynsym就看不到）。这是因为dynsym中的符号只有在动态链接时也就是运行时才能被解析。\n4 参考文献 Executable and Linkable Format Tool Interface Standard (TIS) Executable and Linking Format (ELF)Specification Version 1.2 What’s the difference of section and segment in ELF file format ELF文件格式 ","date":"2025-09-05T11:32:02+08:00","permalink":"https://joker0ops.github.io/p/elf%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%89%96%E6%9E%90/","title":"ELF文件结构与格式剖析"},{"content":"前言 ELF是一种文件格式的名称\nELF（Executable and Linkable Format）是Linux和其他类Unix系统中用于可执行文件、目标文件、共享库（动态链接库）和核心转储（core dumps）的标准文件格式。它定义了程序在存储和运行时的结构，是理解程序编译、链接和加载过程的关键。\n一、ELF文件的类型及其组成的格式 1.1 类型 可执行文件（Executable）：可直接运行的程序（如 /bin/ls）。 目标文件（Relocatable Object File）：编译后的 .o 文件，需链接生成可执行文件。 共享库（Shared Object）：动态链接库 .so，运行时被加载到进程内存。 核心转储（Core Dump）：程序崩溃时的内存快照，用于调试。 1.2 组成格式 ELF文件由以下四部分组成：\n组成部分 作用 ELF Header 描述文件的基本信息（架构、入口地址、段表和节表的位置等）。 Program Headers 描述程序在运行时的内存布局（如代码段、数据段、栈等），用于加载和执行程序。 Section Headers 描述文件的节（section）信息（如代码、数据、符号表等），用于链接和调试。 Data Sections 实际的代码、数据、字符串表、符号表等内容。 常见的节\n代码节（.text）：⽤于保存机器指令，是程序的主要执⾏部分。 数据节（.data）：保存已初始化的全局变量和局部静态变量。 Block Started by Symbol(.bss):是程序内存布局中的一个重要部分，主要用于存储未初始化的全局变量和静态变量 二、ELF文件从形成到加载轮廓 2.1 ELF可执行文件形成过程 - step-1：将多份 C/C++ 源代码，翻译成为⽬标 .o ⽂件\n- step-2：将多份 .o ⽂件section进⾏合并\n2.2 ELF可执行文件从磁盘加载到内存中section的变化 ⼀个ELF会有多种不同的Section，在加载到内存的时候，也会进⾏Section合并，形成segment\n目的是为了节省从磁盘加载到内存过程中的内存空间，一个页大小是4kb（4096字节），如果不合并前.text大小为4097字节，.data是1字节，那么它们会占3个页面，但是合并过后总大小为4098字节，那么只需要两个页，section在链接时起作用而segment在执行时起作用，segment其实就是往下合并section，两者的关系是segment包含section 合并原则：相同属性，⽐如：可读，可写，可执⾏，需要加载时申请空间等. 这样，即便是不同的Section，在加载到内存中，可能会以segment的形式，加载到⼀起 很显然，这个合并⼯作也已经在形成ELF的时候，合并⽅式已经确定了，具体合并原则被记录在了ELF的 程序头表(Program header table) 中 三、理解链接和加载 3.1 静态链接 研究静态链接其实就是研究不同的.o文件是如何链接到一起的，.o类型文件也叫做可重定位目标文件\n以下是样例代码：\n// hello.c #include\u0026lt;stdio.h\u0026gt; void run(); int main() { printf(\u0026quot;hello world!\\n\u0026quot;); run(); return 0; } // code.c #include\u0026lt;stdio.h\u0026gt; void run() { printf(\u0026quot;running...\\n\u0026quot;); } objdump -d 命令：将代码段（.text）进⾏反汇编查看\n以下图片是反汇编后的hello.o文件的汇编码\n其中蓝色圈中的e8代表的就是callq的加载到内存的机械码，而后面跟着的一串0代表访问的函数地址，在链接中才会填充地址，也叫做地址重定位\n静态链接就是把库中的.o进⾏合并，和上述过程⼀样\n所以链接其实就是将编译之后的所有⽬标⽂件连同⽤到的⼀些静态库运⾏时库组合，拼装成⼀个独⽴的可执⾏⽂件。其中就包括我们之前提到的地址修正，当所有模块组合在⼀起之后，链接器会根据我们的.o⽂件或者静态库中的重定位表找到那些需要被重定位的函数全局变量，从⽽修正它们的地址。这其实就是静态链接的过程\n3.2 动态链接 首先交代一个结论：动态链接实际上将链接的整个过程推迟到了程序加载的时候。⽐如我们去运⾏⼀个程序，操作系统会⾸先将程序的数据代码连同它⽤到的⼀系列动态库先加载到内存，其中每个动态库的加载地址都是不固定的，操作系统会根据当前地址空间的使⽤情况为它们动态分配⼀段内存。\n动态库想要和运行程序关联起来需要进行两个步骤\n被程序相关的进程看到：动态库地址映射到进程的地址空间 被进程调用：在地址空间中进行跳转\n动态库（也能被叫做共享库）的意义就是将所有能重复用到的代码在程序需要时放到内存的一片区域中然后不需要再出现重复的代码。 —在C/C++程序中，当程序开始执⾏时，它⾸先并不会直接跳转到 main 函数。实际上，程序的⼊⼝点\n是 _start ，这是⼀个由C运⾏时库（通常是glibc）或链接器（如ld）提供的特殊函数。\n在 _start 函数中，会执⾏⼀系列初始化操作，这些操作包括：\n设置堆栈：为程序创建⼀个初始的堆栈环境。 初始化数据段：将程序的数据段（如全局变量和静态变量）从初始化数据段复制到相应的内存位置，并清零未初始化的数据段。 动态链接：这是关键的⼀步， _start 函数会调⽤动态链接器的代码来解析和加载程序所依赖的动态库（shared_libraries）。动态链接器会处理所有的符号解析和重定位，确保程序中的函数调⽤和变量访问能够正确地映射到动态库中的实际地址。 调⽤ __libc_start_main ：⼀旦动态链接完成， _start 函数会调⽤__libc_start_main （这是glibc提供的⼀个函数）。 __libc_start_main 函数负责执⾏⼀些额外的初始化⼯作，⽐如设置信号处理函数、初始化线程库（如果使⽤了线程）等。 调⽤ main 函数：最后， __libc_start_main 函数会调⽤程序的 main 函数，此时程序的执⾏控制权才正式交给⽤⼾编写的代码。 处理 main 函数的返回值：当 main 函数返回时， __libc_start_main 会负责处理这个返回值，并最终调⽤ _exit 函数来终⽌程序。\n上述过程描述了C/C++程序在 main 函数之前执⾏的⼀系列操作，但这些操作对于⼤多数程序员来说是透明的。程序员通常只需要关注 main 函数中的代码，⽽不需要关⼼底层的初始化过程。然⽽，了解这些底层细节有助于更好地理解程序的执⾏流程和调试问题。 动态链接器：\n◦ 动态链接器（如ld-linux.so）负责在程序运⾏时加载动态库。\n◦ 当程序启动时，动态链接器会解析程序中的动态库依赖，并加载这些库到内存中。\n环境变量和配置⽂件：\n◦ Linux系统通过环境变量（如LD_LIBRARY_PATH）和配置⽂件（如/etc/ld.so.conf及其⼦配置⽂件）来指定动态库的搜索路径。\n◦ 这些路径会被动态链接器在加载动态库时搜索。\n缓存⽂件：\n◦ 为了提⾼动态库的加载效率，Linux系统会维护⼀个名为/etc/ld.so.cache的缓存⽂件。\n◦ 该⽂件包含了系统中所有已知动态库的路径和相关信息，动态链接器在加载动态库时会⾸先\n搜索这个缓存⽂件\n3.2.1 动态库中的相对地址 动态库也是elf类型的文件，当文件链接动态库的时候，发生以下过程\n通过mm_struct中的变量找到有关共享区的结构体，根据里面的成员指针变量找到路径 根据路径找到磁盘中的数据块加载到内存 发生映射关系关联起来 得到库的起始虚拟地址 数据区会有一个名为.GOT的表记录库函数的偏移量，映射过后，表会根据库的起始虚拟地址进行修改得到完整的访问共享区的地址\n总结 这篇博客是博主时隔三个多月再次恢复的博客写作，仍有诸多欠缺，希望看到这篇博客的小伙伴能一起坚持下学习和进步\n","date":"2025-09-05T09:54:19+08:00","permalink":"https://joker0ops.github.io/p/linuxelf%E6%96%87%E4%BB%B6%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%BD%A2%E6%88%90%E8%BD%AC%E8%BD%BD/","title":"Linux：ELF文件\u0026\u0026动静态库的加载和形成（转载）"},{"content":"最近发现自己对 GNU GCC 和 Clang 的区别不太清楚，影响到一些实现和学习，所以趁这两天有空好好研究了一下。\n在这个研究过程中，我发现很多问题其实源自于语言（不是指编程语言，而是中文和英文翻译的失真）和概念理解不严谨。\n如果你上网去查clang，有些人会告诉你这是一个前端（frontend），然后从书上摘抄一些编译器的介绍，然后列出了一堆表格进行对比，并没有对原理和机制进行详尽的解释和介绍。所以这时候会有更多的问题冒出来：\n为什么clang是一个前端？难道它不是完整的编译器吗？如果clang是完整的编译器的话，那么为什么叫前端呢？如果它不是完整的，那么后端是什么呢？ 编译器的定义到底是什么？感觉书上编译器的定义和实际的gcc有所不同。 这里说明一下：这里的gcc指的是你在 Ubuntu 等 Linux 发行版里可以直接使用的命令（来自于 GNU 软件组），如果是指项目则会写作“GNU GCC”。如果是指llvm-gcc，则不会简写成gcc。\n本文将会逐步解答这一系列的问题，在这个过程中，不光会让你搞明白clang到底是什么，也会让你对编译过程、编译器和gcc，以及 LLVM 更加了解。\n像gcc这种现代叫做“编译器”的程序是一个工具集合 需要先理解一件事，也算是上面绝大部分问题的答案或者误解源头：像gcc这种现代“编译器”是一个工具集合，包含了预处理器、编译器，而且会自己调用汇编器、连接器或加载器等多种工具，而不是单单的一个编译器（话说这种术语和名词的冲突也是误导的重要原因之一）。\n先说出答案是为了让读者带着答案去看解释，这样能理解的更好。\n编译器到底是什么（或者说编译流程是什么） 上文提到，“编译器”是一个时常表达有冲突的术语：在很多言论、博客、教科书和专业书中，编译器被描述成“将源代码转换成可执行程序的程序”（比如gcc这个“编译器”就可以直接将源代码变成可执行程序）。这句话简洁、准确地描述了使用gcc命令会发生什么，但是这并不是编译器的定义。\n我们来看看最经典的编译相关的著作《编译原理》（也就是龙书）里对于编译器的介绍，这也算是编译器最经典的含义：\n简单来说，编译器就是一个程序能读取某种语言的一个程序（这个语言是_源_语言），然后将其翻译转换成另一种语言的等价程序（这个语言被称为_目标_语言）。编译器最重要的一个规定就是报告在翻译过程中发现“源”程序的错误。\n如果这个目标程序是机器语言，那么这个目标程序就是可执行程序。\n说人话其实就是：我们写的源代码经过编译器转换之后得到了另一种语言的代码（目标代码），而转换之后的代码如果是机器语言，那么这个目标代码就是可执行程序。但是如果多源代码文件或者有外连接的库，那么可能是共享对象（shared object）。\n“code”在英语中是指一堆数字、字母、符号，中文翻译成“代码”或“码”\n应用程序本质就是一堆机器语言拼成的二进制文件。\n也就是说，编译器实际上是将一种语言转换成另一种语言的程序，也就是用来翻译的程序。\n不过按照近几十年的标准编译流程来说，编译器指的是从将.c等文件转换成.s文件的程序。为了方便解释，除非特地说明，下文中的“编译器”都是按这个定义。\n2024年6月4日更新：\n下面这个编译流程是从 FORTRAN I 开始的。FORTRAN 作为最古老的编程语言，自然也有着世界上第一个编译器。FORTRAN 的名称其实就是“Formula Translated（公式翻译）”，名称中就表达了“翻译”这一含义。\n在这个定义下，编译器内部的工作流程大致如下：\n编译器可以生成指定平台的汇编代码。然后再由汇编器来将汇编代码转成机器语言，最后由连接器连接成可执行程序。\n此外有几点需要补充一下：\n这里的各种语言代码是经过预处理过的； 某语言的前端一般指词汇解析器（Lexer）和语法分析程序（Parser），前端会将源代码一步一步（从高级到低级）转换成优化器需要的中间表达（IR），这是多个分析器实现的的。 一般在优化器前面会单独列出一个“AST（Abstract Syntax Trees）”，这是一个层级很高的中间表达，基本上就是源代码的重组。 优化器（Optimizer）有时也被称为中端（Middle end），优化器不仅提升性能，而且作为中端可以让前后端分离的更好，增加了交叉编译的可能性。 从源代码到高级中间表达，再从中级到低级的流程大致如下：\n这里有篇文章做了更详细的介绍：《Intermediate Representation》\n从源代码转换成可执行程序的过程 从源代码转换成可执行程序的完整过程，也就是我们平时所说的“编译过程”。在过去的几十年里，这个标准流程大致如下（圆角矩形表示代码，矩形表示各种处理器）：\n可以看到从源代码到可执行程序要经过预处理器（preprocessor）、编译器（compiler）、汇编器（assembler）和连接器（linker）或加载器（loader），而编译器只是负责将源代码转换成对应的汇编代码的功能。\n过程展示：gcc和配套的cpp、as、ld处理转换程序 上文提到的的几种处理转换程序除了编译器和汇编器，其他三个估计都很很少听到。下面就用最经典的 C 语言和gcc来介绍这个过程，gcc包含的预处理器为cpp，还会调用汇编器as、连接器ld。\n关于三者的介绍，以及编译过程中，每一步时如何进行的详细过程，可以看看我的另一篇文章《使用gcc展示完整的编译过程》，这篇文章也通过实际操作，介绍了一些gcc操作方法。这篇文章非常建议读到这里就看一看，不然可能只理解字面的内容，文章内容原本是打算放在这里的，但是会让字数到 2 万字，这样阅读时间太长了。\ngcc内部工作流程 gcc内部工作流程如下，这里忽略了预处理过程：\nClang内部的工作流程 随着时代的发展和进步，老式的编译流程已经不够用了：\n性能优化需要的人力、物力过大（现在的汇编语言要比以前的复杂太多了，经典的 PDP-11 手册里关于指令的只有 30 页不到，但是现在 Intel X86 指令手册就 2500 页）； 针对每种机器的开发消耗多（比如说在 ARM 和 X86 编译同一个程序）； 编译器的“插件”不够（有时候需要新的优化或者处理）。 看到这里你便明白，这里的前端是指整个 C 语言家族的编译流程的前端，而不是一个编译器的前端。所以 clang 是一个完整的编译器，可以将.c转换成.s文件，但是可以调用汇编器和编译器生成最终的可执行文件。\nclang 作为编译器可以将你写的 C 家族的语言转换成 LLVM IR（一种低级语言），然后转换输出一个.s文件，然后调用 LLVM 项目中的汇编器（或者其他汇编器）将其汇编成一个.o对象文件（也就是前文中提到的“汇编阶段”），最后调用连接器进行连接，输出一个可执行程序。\n也就是之前描述的编译器内部流程变成如下流程，同样这里的省略了预处理过程：\n2024年3月27日更新：\n之前没注意这个图，直接复制gcc的，忘记修改语言前端后面的内容了。在这个编译管线层级下，LLVM 的优化是对 LLVM IR 进行的，而且不止一次，这取决于你使用-O几，每一级优化的内容也是不同的。所以这里的优化器并不是指“只优化一次”。额外需要说明一点，-O3这个选项并不只在“优化器”部分优化，还会在连接的时候进行一些优化。\n而clang后面使用的的汇编器和连接器，既可以使用 LLVM 集成，也可以使用 GNU 的，比如连接器可以使用 LLVM 集成的的lld，也可以使用 GNU 的ld或gold，以及 MSVC的link.exe。不过默认情况下是使用 LLVM 集成的。\n如果你好奇更详细 Clang 工作流程，和每一步的操作，比如说什么选项对应的是编译过程的某一步，可以看看这篇文档《An Overview of Clang》，我就不单独写博客了。\n这种编译方式对于适配不同平台来说非常方便。当出现一个新的平台，只要将指令与 LLVM IR 对应即可，完全不用开发者去写一个全新的优化器和代码生成器去将源代码转换成汇编代码，省时省力。\n为什么clang是一个前端？难道它不是完整的编译器吗？如果clang是完整的编译器的话，那么为什么叫前端呢？如果它不是完整的，那么后端是什么呢？ Clang 是一个完整的编译器，也是一个前端。不过是将源代码转换成可执行程序流程的前端，而不是编译器的前端。如果说是编译器的前端，那是预处理器、词义分析器（Lexer）和语法分析器（Parser）等部分构成的。\n和clang对应的后端指的是 LLVM 内含的，或者 GNU 等软件组的连接器、编译器等工具，这些工具负责将汇编代码汇编、连接成最后的可执行文件。\n编译器的定义到底是什么？感觉书上编译器的定义和实际的gcc有所不同 关于编译器的定义前文有详细的解释，现在一般情况下“编译器”指的是从将.c等文件转换成.s文件的程序。\n实际上编译器，比如gcc包含了一些工具（比如预处理器），也会去调用其他的工具（汇编器和连接器），所以与定义有所不同。\nLLVM 项目是干什么项目？ 前文提到，很多编译器是需要多个中间表达（IR）的，这些中间表达可能是词汇分析器生成的，也可能是语义分析器生成的，就很不统一，这就导致更新指令和优化性能随着数量的大幅提升成为了一件很困难的事情。\nLLVM 全名“Low-Level Virtual Machine”，是一架构和中间表达的实现。而 LLVM 项目最初是一套围绕着 LLVM 代码的工具，C 语言和对应的 LLVM 代码如下（源自Chris Lattner 的《Architecture for a Next-Generation GCC》）：\nLLVM 代码有三种用途：\n编译器的中间表达； 存放在硬盘里的位码（bitcode）； 人类可读的汇编语言表达 这三种用途实际上都是等价的，要么能共用，要么有工具可以很轻松的转换，这点就让 LLVM 兼容新的机器、优化性能、开发新的语言，甚至是反汇编都是很容易的。\n整个项目最核心内容其实就是 LLVM IR。LLVM IR 旨在成为某种“通用IR”，希望足够低级，可以将高级代码干净地映射到 LLVM IR（类似于处理器使用的指令是“通用IR”，允许将许多种不同的语言映射到这些汇编语言）。这给使用 LLVM IR 的编译器带来了性能很不错提升。\n关于 LLVM 设计更详细的介绍还是请看文档：《LLVM Language Reference Manual》。\n关于 LLVM 带来的性能提升可以看 Intel 的这篇文章：《Intel® C/C++ Compilers Complete Adoption of LLVM》\ngcc和clang有什么区别？ LLVM 早期有一个名为llvm-gcc的项目，它和 GNU GCC 的最大区别就在于：llvm-gcc在编译器最后使用的是 LLVM 作为最低一级的中间表达，而不是 GNU GCC 使用的的 RTL 作为最低一级的中间表达，所以llvm-gcc编译器的最后一部分是处理 LLVM IR，而不是处理 RTL（Register Transfer Language）。\n其他方面，llvm-gcc和gcc一样将会输出一个汇编文件，工作原理也一样。不过可以通过使用-emit-llvm选项来让llvm-gcc输出 LLVM 字节码。\n后来 LLVM 创始人 Chris Lattner 在苹果的时候就开创了一个中间表达全部使用 LLVM 作为中间表达的 C 语言家族的编译器，也就是 Clang。\n虽然clang淘汰了llvm-gcc，虽然现在还是有llvm-gcc，但是使用率和性能都不如clang。也正是因为 LLVM IR，Clang进行反汇编也很方便。\n下面是 Chris Lattner 简历中提到 Clang 诞生的部分（https://www.nondot.org/sabre/Resume.html#Apple）：\n这里字太小了，机翻一下：\n总结一下，gcc和clang的区别在于：clang的各个中间层均为 LLVM IR，而gcc的各个中间层为 RTL 或其他一些事物。\n这里需要注意一点，llvm-gcc和 LLVM 创始人 Chris Lattner 在《Architecture for a Next-Generation GCC》中描述的 LLVM 编译器不是一个东西。这个 LLVM 编译器与后来的 Clang 也不是一个东西。论文中对 LLVM 编译器的示意图如下：\n区别在于中间加了一个连接层，整个编译器中进行了两次连接。不过很明显，根据 Intel 的数据来看， LLVM 编译器的性能和效果相比 GNU GCC 差不多。不过现在你还是可以在 GitHub 上下到它，目前最新版本为 16：https://github.com/llvm/llvm-project/releases/tag/llvmorg-16.0.0\n你可以选择和clang一起下载：\n也可以单独下载：\n","date":"2025-09-04T17:45:36+08:00","permalink":"https://joker0ops.github.io/p/clang%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E8%BD%AC%E8%BD%BD/","title":"Clang到底是什么?(转载)"},{"content":"GNU介绍 GNU是一个由理查德·斯托曼发起的自由软件项目，其全称是“GNU\u0026rsquo;s Not Unix!”。GNU项目的目标是创建一个完全自由的操作系统，包括一整套完全自由的软件工具，以取代Unix系统。这里的“自由”指的是自由软件（Free Software）的概念，即用户有使用、复制、修改和分发软件的自由。\nGNU关键组件 GNU操作系统：包括内核、shell、编程语言编译器、文本编辑器、文件系统等组件。 软件自由性：用户有权自由地运行、学习、分享和改进软件。 GNU通用公共许可证（GPL）：GNU项目开发了一种许可证，即GNU通用公共许可证，它允许软件以自由软件的形式分发和使用。 GNU重要软件 Bash：Bourne Again Shell，一个Unix shell和命令语言。 GCC：GNU编译器集合（GNU Compiler Collection），支持多种编程语言的编译器。 GDB：GNU调试器（GNU Debugger），用于调试程序。 GNU Hurd：GNU项目开发了自己的内核，称为Hurd，它是GNU系统的一部分，但Hurd的开发进度较慢，并没有广泛部署。 GNU/Linux：虽然GNU Hurd的开发没有达到预期，但GNU项目开发的许多组件被用于Linux操作系统中。Linux内核与GNU工具集合合，形成了广泛使用的操作系统，通常被称为GNU/Linux。 编译器介绍 编译器是一种将高级语言编写的源代码转换为计算机可执行的机器语言或低级语言的程序，其本质是一种翻译程序，核心功能包括词法分析、语法分析、代码优化及目标代码生成等。\n编译器的一般构成 传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。\n几种常见的编译器 GCC GCC（GNU Compiler Collection，GNU编译器套装），是一套由 GNU 开发的跨平台编程语言编译器。GCC 原名为 GNU C 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 C++、Fortran、Pascal、Objective-C、Java, 以及 Ada、Go 等他语言。常用于嵌入式系统和高性能计算领域。\nLLVM LLVM（Low Level Virtual Machine，底层虚拟机）提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成等。可以作为多种编译器的后端使用。在LLVM项目开发的初期，主要使用GCC作为前端；后期由Apple主导开发的Clang作为前端将源代码翻译成LLVM IR这一中间代码，然后由LLVM将这一中间代码转换成机器语言。\nClang Clang是LLVM项目的前端编译器，专注于C、C++和Objective-C等语言的编译。Clang由Apple公司主导编写，并逐渐成为了业界知名的编译器之一。Clang以其快速编译速度、较小内存占用和清晰的诊断信息，赢得了广大开发者的喜爱。此外，Clang还提供了静态分析功能，有助于开发者在编译阶段就发现潜在的问题，如内存泄漏、未初始化变量等。\nMSVC MSVC，全称Microsoft Visual C++，是微软开发的编译器工具链。它主要用于Windows平台应用程序的开发，并通常与Visual Studio IDE集成在一起。MSVC提供了从编写代码到调试、部署的完整开发环境，是Windows应用开发者的首选编译器之一。MSVC主要用于Windows平台的应用程序开发。它是Visual Studio IDE的默认编译器之一，支持C++、C#等多种编程语言。此外，MSVC还被用于游戏开发、桌面应用开发等领域。\n从源代码到可执行程序 编译流程 1 2 3 (源代码) --预处理器--\u0026gt; (调整之后的代码) --编译器--\u0026gt; (汇编语言代码) --汇编器--\u0026gt; (可调整的机器语言代码) --连接器或加载器--\u0026gt; (可执行程序) 可以看到从源代码到可执行程序要经过预处理器（preprocessor）、编译器（compiler）、汇编器（assembler）和连接器（linker）或加载器（loader），而编译器只是负责将源代码转换成对应的汇编代码的功能。\ngcc的各种处理转换程序 在gcc的编译过程中，除了调用其本身包含的编译器和预处理器cpp，还会调用外部程序提供的汇编器as和连接器ld\n预处理阶段 1 gcc -E 源代码 -o XXX.i 注意：如果需要在预处理之后停止需要使用选项-E，-o用于指定输出文件的名称。（gcc调用的预处理器cpp会将源文件处理后直接输出到标准输出，而不是生成某个文件！）\n编译阶段 1 gcc -S XXX.i 如果你想编译但不进行汇编，那么使用-S选项，编译后会生成一个新的.s汇编文件\n汇编阶段 1 gcc -c XXX.s 汇编阶段使用选项-c来进行编译和汇编，但是不进行连接。刚才是进行了编译，但是没有汇编，所以这里使用-c相当于只使用了汇编器。汇编阶段完成后，会自动生成新的对象文件（object file），文件后缀为.o。\n连接阶段 1 gcc -o XXX XXX.o 最后的连接阶段，使用-o直接输出可执行文件即可，因为从汇编之后的对象文件到可执行程序和从源代码到可执行程序这个结果是一样的，gcc这些选项只是限定“终点”。注意：绝大多数编译器的使用几乎等价gcc+选项，除了一些小细节。唯一大不同的是连接器。\ngcc与g++的区别 gcc 是 GCC 编译器的通用编译指令，因为根据程序文件的后缀名，gcc 指令可以自行判断出当前程序所用编程语言的类别。gcc 指令也为用户提供了“手动指定代表编译方式”的接口，即使用 -x 选项 xxx.c：默认以编译 C 语言程序的方式编译此文件； xxx.cpp：默认以编译 C++ 程序的方式编译此文件。 xxx.m：默认以编译 Objective-C 程序的方式编译此文件； xxx.go：默认以编译 Go 语言程序的方式编译此文件； g++ 指令，则无论目标文件的后缀名是什么，该指令都一律按照编译 C++ 代码的方式编译该文件。 ","date":"2025-09-04T14:16:50+08:00","permalink":"https://joker0ops.github.io/p/gnu/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%8A%E5%85%B6%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/","title":"GNU/GCC编译器及其编译流程详解"},{"content":"信号的基本概念 信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件。但是，不能使用信号给进程传递任何数据。 信号产生的原因有很多，在Shell中，可以用kill和killall命令发送信号：\nkill -信号类型 进程编号\nkillall -信号类型 进程名\n信号的类型(以下仅列出最需要关注的信号类型) 信号名 信号值 默认处理动作 发出信号的原因 SIGINT 2 A 键盘中断 Ctrl+c SIGKILL 9 AEF 采用 kill -9 进程编号 强制杀死程序 SIGSEGV 11 CEF 无效的内存引用（数组越界、操作空指针和野指针等） SIGALRM 14 A 由闹钟 alarm() 函数发出的信号 SIGTERM 15 A 采用 kill 进程编号 或 killall 进程名 通知程序 SIGCHLD 17 B 子进程结束信号 其他 ≤64 A 自定义信号 默认处理动作的含义如下:\nA 终止进程。 B 忽略此信号，将该信号丢弃，不做处理。 C 终止进程并进行内核映像转储（core dump）。 D 停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。 E 信号不能被捕获。 F 信号不能被忽略。 信号的作用 当服务程序运行时，使用信号直接杀掉该进程可能会导致一些资源未能来得及释放从而造成内存占用等一系列问题。如果向服务程序发送一个信号，服务程序收到信号后能够去主动调用退出处理函数，就能使进程有计划地退出。如果向进程发送0信号，可以检测进程是否存活。\n发送信号 在程序中，可以使用kill()函数向其他进程发送信号。 函数声明：\n1 2 int kill(pid_t pid, int sig); // kill 函数可以将信号sig发送给指定的进程pid 参数pid的几种情况：\npid\u0026gt;0 将信号传递给进程号为pid的进程 pid=0 将信号传递给和当前进程同进程组的所有进程，常用于父进程给子进程发送信号。（信号发送进程也会收到自己发出的信号） pid=-1 将信号广播给系统内的所有进程。（示例：关机） 参数sig说明：准备发送的信号代码，若sig=0不发出任何信号，但系统会执行错误检查，通常会利用sig值为零来检查某个进程是否仍在运行。 返回值说明：成功执行时，返回0；失败返回-1，errno被设置。\n进程终止 正常终止 异常终止 main函数return 调用abort函数中止 exit()函数调用 接收到中止信号 _exit()/Exit()函数调用 在最后一个线程中对取消请求做出响应 最后一个线程从其启动例程中return 在最后一个线程中调用pthread exit()返回 进程终止状态 在main()函数中，return的返回值即终止状态，如果没有return语句或调用exit()，那么该进程的终止状态是0。该性质常用于服务程序的调度、日志和监控。在Shell中，程序运行结束时可以使用echo $?查看进程终止的状态。 正常进程终止的三个函数：\n1 2 3 4 void exit(int status); void _exit(int status); void _Exit(int status); // status 表示进程终止状态 其中，exit()和_Exit()是由ISO C说明的，_exit()是由POSIX说明的。\n资源释放的问题 当进程使用return语句返回时，会调用局部对象的析构函数。main()函数中的return还会调用全局对象的析构函数。\nexit()表示终止进程，不会调用局部对象的析构函数，只调用全局对象的析构函数。exit()会执行清理工作然后退出，_exit()和_Exit()则不执行清理工作直接退出。\n进程的终止函数 进程可以使用atexit()函数登记终止函数（最多32个），这些函数将由exit()自动调用。\n1 2 int atexit(void (*function)(void)); exit() 调用终止函数的顺序的顺序与登记时相反。进程退出前的收尾工作。 ","date":"2025-08-18T09:47:50+08:00","permalink":"https://joker0ops.github.io/p/linux%E7%9A%84%E4%BF%A1%E5%8F%B7/","title":"Linux的信号"},{"content":"","date":"2024-08-18T21:25:54+08:00","image":"https://joker0ops.github.io/p/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80numpy%E5%85%A5%E9%97%A8/17_hub468cb9e2e0fb22530e23a0e0293acef_781019_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80numpy%E5%85%A5%E9%97%A8/","title":"Python数据分析基础——Numpy入门"},{"content":"IPython与Jupiter是什么？ IPython是Python的一个交互式解释器，可以提供交互式命令行，支持自动补全、历史记录等功能。Jupyter是IPython的一个扩展，可以提供交互式命令行、Markdown文档、代码块等功能。当你使用%run命令时，IPython会在同一个进程内执行指定文件中的代码，确保你能够在执行完成时立即探索结果。 IPython的使用 启动IPython 像启动标准Python解释器一样，你可以ipython命令启动IPython命令行。 IPython的交互式命令行 你可以将Python语句输入命令行，然后按下回车键运行。当你在IPython命令行中仅仅输入一个变量名后，它会返回一个表示该对象的字符串： IPython输出风格 与常见的print打印语句不同，IPython会将输出格式化为一个更易读的格式。\n1 2 3 4 5 6 7 8 9 10 import numpy as np data = {i:np.random.randn() for i in range(7)} data {0: -0.4046457180241955, 1: -2.27136111318475, 2: 1.7273107463935018, 3: -1.364839504945707, 4: -1.957277837917039, 5: -0.5369751270845555, 6: 0.9250198022472945} IPython的Tab补全功能 相较于标准Python命令行，IPython增添了Tab补全功能。通常这种功能只在IDE或者其他交互式计算分析环境中提供。当在命令行中输入一个表达式时，按下Tab键可以自动搜索能够匹配当前表达式的自定义变量、关键字、内建函数、方法、属性、名称、关键字参数等。另外需要导入的模块也可以通过相同的方式进行补全。并且在新版的IPython中，自动补全是在下拉列表中进行的，需要在补全列表中选择一个选项，然后按回车键执行。\n请注意IPython默认情况下隐藏了以下划线开始的方法和属性，诸如魔术方法，内部“私有”方法和属性以防止新手混淆，这些属性必须先输入下划线才可以看到\n此外，Tab补全功能还可以用于对计算机文件系统的搜索，当输入任意路径（甚至是Python字符串）时，按下Tab键可以自动补全文件和目录名。这与%run命令搭配使用能够节省大量的输入时间（%run + Tab补全文件路径）。\n内省 在一个变量名前后使用问号(?)可以显示一些关于该对象的概要信息：\n1 array? 这就是对象内省。如果对象是一个函数或实例方法且文档字符串已经写好，则文档字符串就会显示出来。例如：\n1 2 3 4 5 6 7 8 def exchange_numbers(a, b): \u0026#34;\u0026#34;\u0026#34; Exchange two numbers without a temp variable Returns -------- b, a \u0026#34;\u0026#34;\u0026#34; return b, a 然后使用?显示对象的完整文档字符串：\n1 exchange_numbers? 使用双问号??可以显示函数源代码：\n1 exchange_numbers?? 此外?操作符还有一个终极用途，可以结合通配符*使用，例如我们可以得到Numpy顶层函数中包含load的函数名列表：\n1 2 3 4 5 6 np.*load*? np.__loader__ np.load np.loads np.loadtxt np.pkgload %run命令 在Juypter中可以使用%run命令运行任意的Python程序文件，并且Jupyter提供了良好的用户输入接口。\n在%run FileName.py这行命令中，脚本是在一个独立的空白命名空间中运行的，之前导入的模块或定义的变量对其不会造成影响。（类似于在一个单独的命令行中执行python FileName.py）。\n在程序执行期间，按下Ctrl+C可以中断程序。除了某些特殊情况，这将导致所有的Python程序立即停止运行。但需要注意的是，当一段Python代码被其他已经编译的扩展模块调用时，按下Ctrl+C将不会中断程序。在这些情况下，你需要等到控制流重新返回Python解释器，甚至有时还需要强制结束Python进程。\n关于魔术命令 IPython中存在一些特殊的内置命令称为魔术命令，它们以%开头，用于简化常见任务。例如：\n指令 功能 %time statement 命令可以测量一段代码的执行时间 %timeit statement 命令多次运行单个语句计算平均时间 %pwd 命令可以显示当前工作目录 %cd 命令可以改变当前工作目录 %ls 命令可以列出当前工作目录下的文件 %matplotlib 命令可以启用matplotlib绘图功能 %edit 命令可以打开一个Python程序文件的编辑器 %debug 命令可以启动调试器 %hist 命令可以显示命令历史记录 %pdb 命令可以启用Python调试器 %who, %who_ls, %whos 命令可以显示当前工作空间中的变量 %quickref 命令可以打开一个快速参考手册 %magic 命令可以列出所有魔术命令的详细文档 %paste 命令可以从剪贴板中执行已经预先格式化的Python代码 %cpaste 命令可以打开一个特殊提示符，然后手动粘贴待执行的Python代码 %reset 命令可以重置当前工作空间，删除当前工作空间中的所有变量和函数 %page OBJECT 通过分页器更美观地打印显示一个对象 %xdel variable 命令可以删除一个变量并清除相关的引用 Tips:\n魔术命令可以看作IPython系统内部的命令行程序，大多数魔术命令都可以在其后追加?操作符来显示更加详细的文档 1 In[1]: %time? 只要没有变量定义为与魔术命令相同的名字，魔术命令即可不加%使用，这种特性可以通过%automagic命令来启用或禁用 一些魔术命令（例如%pwd）也像Python函数一样，其输出可以赋值给一个变量。 1 2 In[2]: pwd = %pwd In[3]: pwd matplotlib集成 IPython良好得集成了matplotlib，在IPython中，运行%matplotlib命令可以生成多个绘图窗口而不会干扰控制台的会话。\n1 2 3 4 In[1]: %matplotlib In[2]: import matplotlib.pyplot as plt In[3]: import numpy as np In[4]: plt.plot(np.random.randn(50).cumsum(), \u0026#39;k--\u0026#39;) 在Jupyter中，命令会有所不同： Jupyter的使用 Jupyter是一个基于Web的交互式计算分析环境，可以运行多种数据分析语言。一般安装Anaconda时，已经安装了Jupyter。 在使用Jupyter时，需要打开命令行输入jupyter notebook命令，然后打开浏览器访问localhost:8888。一般情况下，Jupyter会自动打开一个浏览器窗口（除非你使用了 \u0026ndash;no-browser 选项）同时，你可以在jupyter notebook命令后面追加目录来指定Jupyter的默认打开地址。 ","date":"2024-03-22T22:04:01+08:00","image":"https://joker0ops.github.io/p/ipython%E4%B8%8Ejupyter%E7%9A%84%E4%BD%BF%E7%94%A8/10_hu8625cb07d962bca02a4ea674454ebd55_242272_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/ipython%E4%B8%8Ejupyter%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"IPython与Jupyter的使用"},{"content":" 1 2 Ctrl + Ins 复制 Shift + Ins 粘贴 ","date":"2024-03-05T17:08:38+08:00","image":"https://joker0ops.github.io/p/gitbash%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%BF%AB%E6%8D%B7%E9%94%AE/34_hu1fcfd80b17ed2a5f977b43a96e67bcb1_715245_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/gitbash%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"GitBash复制粘贴快捷键"},{"content":"Qt信号与槽机制 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。\n使用系统自带的信号和槽实现关闭窗口功能 首先需要创建一个按钮用于触发“关闭窗口”信号：\n1 QPushButton *btn = new QPushButton(\u0026#34;关闭窗口\u0026#34;, this); 然后我们可以通过connect函数进行信号的连接操作，connect函数的一般形式为：\n1 connect(sender, signal, receiver, slot); 参数解释：\nsender：发出信号的对象 signal：发送对象发出的信号（函数的地址） receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数（槽函数） 此处即体现出信号和槽机制松散耦合的优点：信号发送端和接收端本身没有关联，但可以通过connect进行连接将两端耦合在一起。 随后，填入相应实参即可调用connect函数进行信号连接。\n1 connect(btn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::close); 那么系统自带的信号和槽通常如何查找呢？这个就需要利用帮助文档了，比如这里我们需要的是QPushButton的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，但发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个\n1 2 3 4 5 6 void clicked(bool checked = false) void pressed() void released() void toggled(bool checked) - 3 signals inherited from QWidget - 2 signals inherited from QObiect 这里的clicked就是我们需要的signal函数，槽函数的寻找方式和信号一样，只不过他的关键字是slot。\n自定义信号与槽函数 定义两个继承自QObject的类——Teacher和Student，实现一个场景：上课铃响后，老师喊上课，学生们收到上课的信号回教室坐好。\nteacher.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #ifndef TEACHER_H #define TEACHER_H #include \u0026lt;QObject\u0026gt; class Teacher : public QObject { Q_OBJECT public: explicit Teacher(QObject *parent = nullptr); signals: // 自定义信号 写到signal下 // 返回值是void，只需要声明，不需要实现 // 可以有参数，可以发生重载 void ClassBegin(); public slots: // 自定义槽函数，写到slot下 }; #endif // TEACHER_H student.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #ifndef STUDENT_H #define STUDENT_H #include \u0026lt;QObject\u0026gt; class Student : public QObject { Q_OBJECT public: explicit Student(QObject *parent = nullptr); signals: public slots: // 早期Qt版本必须要写到public slots下，高级版本可以写到public或者全局下 // 返回值void，需要声明也需要实现 // 可以有参数，也可以发生重载 void SitDown(); }; #endif // STUDENT_H student.cpp 1 2 3 4 5 6 7 8 9 10 #include \u0026#34;student.h\u0026#34; #include \u0026lt;QDebug\u0026gt; Student::Student(QObject *parent) : QObject(parent) { } // 自定义成员函数记得加函数返回值类型 void Student::SitDown(){ qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好\u0026#34; \u0026lt;\u0026lt; endl; } widget.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #ifndef WIDGET_H #define WIDGET_H #include \u0026lt;QWidget\u0026gt; #include \u0026#34;teacher.h\u0026#34; #include \u0026#34;student.h\u0026#34; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private: Ui::Widget *ui; // 声明teacher和student类型成员变量 Teacher *tp; Student *sp; // 声明上课铃响函数 void Ring(); }; #endif // WIDGET_H widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;widget.h\u0026#34; #include \u0026#34;ui_widget.h\u0026#34; #include \u0026lt;QPushButton\u0026gt; Widget::Widget(QWidget *parent): QWidget(parent), ui(new Ui::Widget) { ui-\u0026gt;setupUi(this); QPushButton *btn = new QPushButton(\u0026#34;关闭窗口\u0026#34;, this); /* * 新建信号连接函数 * 参数1：信号发送者 * 参数2：发送的具体的信号（函数的地址） * 参数3：信号的接收者 * 参数4：信号的处理——槽函数地址（槽） * 信号和槽的优点——松散耦合：信号发送端和接收端本身没有关联，但可以通过connect进行连接将两端耦合在一起 */ // 参数2和参数4写父类子类都可以 connect(btn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::close); // 创建对象并指定父窗口 this-\u0026gt;tp = new Teacher(this); this-\u0026gt;sp = new Student(this); // 情景：上课铃响后，老师发出上课信号，学生响应信号，坐好 // 老师说上课，学生坐好的连接 connect(tp, \u0026amp;Teacher::ClassBegin, sp, \u0026amp;Student::SitDown); // 调用上课铃响函数 Ring(); } // 自定义的类方法记得加返回值类型 void Widget::Ring(){ // 上课函数，调用后触发老师喊上课的信号 emit tp-\u0026gt;ClassBegin(); } Widget::~Widget() { delete ui; } 此时的代码执行流程为：\n调用Ring()函数\u0026ndash;\u0026gt;触发老师喊上课信号\u0026ndash;\u0026gt;回调connect函数\u0026ndash;\u0026gt;学生收到信号\u0026ndash;\u0026gt;调用SitDown函数\n重载信号与槽函数 信号和槽函数均可发生重载\nstudent.h 1 void SitDown(QString ClassName); student.cpp 1 2 3 4 5 6 7 8 void Student::SitDown(QString ClassName){ // 直接使用此方式打印会使得ClassName带引号（QString类型字符串），需要转换为char*类型字符串 // qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好并拿出\u0026#34; \u0026lt;\u0026lt; ClassName \u0026lt;\u0026lt; \u0026#34;课本\u0026#34; \u0026lt;\u0026lt; endl; // QString -\u0026gt; char* 先转换成QByteArray再转成char* // 下面这种方式会多出一个空格 // qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好并拿出\u0026#34; \u0026lt;\u0026lt; ClassName.toUtf8().data() \u0026lt;\u0026lt; \u0026#34;课本\u0026#34; \u0026lt;\u0026lt; endl; qDebug() \u0026lt;\u0026lt; (\u0026#34;学生都坐好并拿出\u0026#34; + ClassName + \u0026#34;课本\u0026#34;).toUtf8().data() \u0026lt;\u0026lt; endl; } teacher.h 1 void ClassBegin(QString ClassName); widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Widget::Widget(QWidget *parent): QWidget(parent), ui(new Ui::Widget) { ui-\u0026gt;setupUi(this); ... // 创建对象并指定父窗口 this-\u0026gt;tp = new Teacher(this); this-\u0026gt;sp = new Student(this); // 情景：上课铃响后，老师发出上课信号，学生响应信号，坐好 // 老师说上课，学生坐好的连接 // 当发生信号或槽函数重载后，connect无法分清是哪个函数发生了重载，需要通过函数指针重新指定函数地址 // connect(tp, \u0026amp;Teacher::ClassBegin, sp, \u0026amp;Student::SitDown); // 函数指针写法： // 函数返回值类型(命名空间:: *指针名)(参数类型1， 参数类型2...) = 函数地址 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 调用上课铃响函数 Ring(); } // 自定义的类方法记得加返回值类型 void Widget::Ring(){ // 上课函数，调用后触发老师喊上课的信号 // emit tp-\u0026gt;ClassBegin(); emit tp-\u0026gt;ClassBegin(\u0026#34;语文\u0026#34;); } 使用信号连接信号 程序情景：点击一个上课的按钮，再触发上课铃响，然后老师叫同学们坐好上课。\n1 2 3 4 5 6 7 8 9 10 11 // 通过函数指针重新指定有参函数的地址 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; // 通过函数指针重新指定无参函数的地址 void(Teacher:: *tsignal)(void) = \u0026amp;Teacher::ClassBegin; void(Student:: *ssignal)(void) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 使用按钮调用Ring函数 QPushButton *classbtn = new QPushButton(\u0026#34;上课\u0026#34;, this); classbtn-\u0026gt;move(100, 0); connect(classbtn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::Ring); 程序情景：点击上课的按钮直接触发老师喊上课信号，然后老师喊同学们坐好上课。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; // 通过函数指针重新指定无参函数的地址 void(Teacher:: *tsignal)(void) = \u0026amp;Teacher::ClassBegin; void(Student:: *ssignal)(void) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 使用按钮调用Ring函数 QPushButton *classbtn = new QPushButton(\u0026#34;上课\u0026#34;, this); classbtn-\u0026gt;move(100, 0); // connect(classbtn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::Ring); // 使用按钮直接连接老师上课信号（有参），让老师上课信号作为槽函数再连接学生坐好的槽函数 connect(classbtn, \u0026amp;QPushButton::clicked, tp, tsignal); connect(tp, tsignal, sp, ssignal); 程序情景：点击上课按钮触发老师喊上课的信号，但学生不听老师的，不坐好\n1 2 // 使用disconnect函数断开连接 disconnect(tp, tsignal, sp, ssignal); Qt4版本信号和槽的写法 1 connect(zt,SIGNAL(ClassBegin(QString)),st,SLOT(SitDown(QString))); 这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到**connect()**函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。 Qt5在语法上完全兼容Qt4，而反之是不可以的。\nLambda表达式 Lambda是属于C++11的新特性。在早期版本(Qt4之前)需要在.pro文件中添加：CONFIG += c++11 C++中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。Lambda表达式的基本构成为：\n1 2 3 4 // 函数定义： [函数对象参数](操作符重载函数参数)mutable-\u0026gt;返回值类型{函数体} // 函数调用： (); 函数对象参数[]，标识一个Lambda的开始，必须存在。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：\n函数对象参数 解析 空 没有使用任何函数对象参数。 = 函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 this 函数体内可以使用Lambda所在类中的成员变量。若在connect函数中使用this时，前面的信号接收者(或信号发送者)可省略 a 将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。 \u0026amp;a 将a按引用进行传递。 a, \u0026amp;b 将a按值进行传递，b按引用进行传递。 =, \u0026amp;a, \u0026amp;b 除a和b按引用进行传递外，其他参数都按值进行传递。 \u0026amp;, a, b 除a和b按值进行传递外，其他参数都按引用进行传递。 操作符重载函数参数标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(\u0026amp;a,\u0026amp;b)）两种方式进行传递。\n可修改标示符即mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身，再次访问传入的函数对象参数时仍是原值）。\n1 2 3 4 5 6 7 8 9 10 QPushButton * myBtn = new QPushButton (this); QPushButton * myBtn2 = new QPushButton (this); myBtn2-\u0026gt;move(100,100); int m = 10; // 点击按钮输出110 connect(myBtn,\u0026amp;QPushButton::clicked,this,[m] ()mutable { m = 100 + 10; qDebug() \u0026lt;\u0026lt; m; }); // 点击按钮输出10 connect(myBtn2,\u0026amp;QPushButton::clicked,this,[=] () { qDebug() \u0026lt;\u0026lt; m; }); // 输出10 qDebug() \u0026lt;\u0026lt; m; 函数返回值-\u0026gt;返回值类型，标识函数返回值的类型。当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n函数体{}标识函数的实现，这部分不能省略，但函数体可以为空。\n使用Lambda表达式的优点： 在connect函数中使用Lambda表达式，可以更加方便地使用有参槽函数。\n信号和槽总结 信号可以连接信号 一个信号可以连接多个槽函数。如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号也可以连接同一个槽函数。只要任意一个信号发出，这个槽就会被调用。 信号和槽函数的参数类型必须一一对应 信号的参数个数可以多于槽函数的参数个数，但除了多出来的参数，剩下的参数类型仍然要一一对应。 信号槽可以通过disconnect函数断开连接 槽可以被取消链接。但这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 信号和槽函数返回值是 void 信号只需要声明，不需要实现 槽函数需要声明也需要实现 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 ","date":"2024-02-17T16:02:44+08:00","image":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_04/31_hu257b54557e64e568910f9552664481a3_2550935_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_04/","title":"QT学习记录_04"},{"content":"创建Github Pages 要想把个人博客托管在Github Pages上，首先在GitHub上创建一个Repository，命名为：{your_username}.github.io比如我的仓库就叫codingxiaoma.github.io 如果你对你的username不满意，需要先在Setting-\u0026gt;Account-\u0026gt;Change username修改一个你满意的username。 注： Repository的前缀 (.github.io之前的内容) 一定要跟你的username保持一致。 仓库的权限需要选择Public, 否则无法访问。\n勾选Add a README.md，主要是为了自动创建main分支。\n然后在你的 仓库xx.github.io里面点击Settings, 左边的菜单栏找到Pages。 可以看到Your site is live at https://codingxiaoma.github.io/ 此时Github Pages就自动部署好了。点击Visit Site就可以看到你的网站了（因为我们的仓库是空的，所以网站也是空的）\nHugo站点和目标文件 现在我们有了Hugo个人站点，有了Github Pages，那么下一步就是把Hugo博客发布到github。这样我们才能在互联网的任何地方访问我们的博客。\n在我们本地的hugo根目录中执行hugo指令。会生成一个public文件夹，我们只需要把public的文件夹上传到Github上刚才创建的仓库里面, 一分钟左右，就能正常查看博客内容。\n这里解释一下：\nhugo站点（hugo根目录）：这个是源文件，也就是你写Markdown的地方，可以不用提交到github，也可以选择在github上创建一个新的repo，并提交。 public文件（hugo/public）：这个是目标文件，是使用hugo指令生成的发布HTML内容，可以在浏览器浏览的格式，需要推送到Github上然后发布到Github Pages静态网站上。 我们的hugo站点是源文件（带主题，图片，markdown源文件），public是目标文件（最终生成的css/js/html文件）。我们最终网页上展示的是目标文件，所以需要使用hugo指令生成目标文件。 发布博客到Github Pages 在任意hugo站点外（是为了以后把hugo源文件也上传到github，git是不能有层级的，所以要放在站点外）直接用git clone把创建好的github仓库克隆下来。\n1 git clone git@github.com:codingxiaoma/codingxiaoma.github.io.git 然后把public里面的所有内容复制到这个Git仓库(codingxiaoma.github.io)并执行：\n1 2 3 git add * git commit -m \u0026#34;first commit\u0026#34; git push 即可成功把内容push到远程仓库。\n复杂一点但是方便的办法为了不要每次改动都手动复制，我们可以创建一个public目录和github仓库的软链接。(需要先删除public目录)\n1 2 3 4 5 6 7 # 进入你的hugo根目录 # 删除public文件夹 rm -rf public # 前面是 github.io仓库的本地目录，后面是 public文件夹的本地​目录 ln -s /Users/hugo/codingxiaoma.github.io /Users/hugo/codingxiaoma/public 然后在hugo根目录下使用hugo指令，就会自动在public软链接也就是git repo下生成目标文件。 最终执行git add/commit/push之后，打开 https://codingxiaoma.github.io/ 就能看到博客内容。(可能有几分钟延迟，耐心等待)。 如果git push提示没有权限\n1 2 3 4 ERROR: Permission to left-pocket-test/left-pocket-test.github.io.git denied to left-pocket. fatal: Could not read from remote repository. Please make sure you have the correct access rights 说明还没有在Github上添加本机电脑的ssh key。 在本地生成ssh key：\n1 2 3 4 5 6 # 查看本地是否有已经生成的SSH密钥 ls -al ~/.ssh # 没有则重新创建SSH密钥 cd ~/.ssh ssh-keygen -t ed25519 -C \u0026#34;xxx@xxx.com\u0026#34; # 填写你的邮箱地址 然后一路Enter到底（如有需要可以键入默认文件位置和自定义安全密码）。\n然后就会在~/.ssh/目录生成默认的文件:\nid_rsa 私钥 id_rsa.pub 公钥 在新的管理提升终端窗口（PowerShell或CMD）中，确保ssh代理正在运行。可以使用“自动启动ssh代理”说明使用SSH密钥密码”，或手动启动它：\n1 2 3 # start the ssh-agent in the background Get-Service -Name ssh-agent | Set-Service -StartupType Manual Start-Service ssh-agent 在没有提升权限的终端窗口中，将SSH私钥添加到ssh代理中。如果使用不同的名称创建了密钥，或者如果正在添加具有不同名称的现有密钥，请将命令中的id_ed25519替换为私钥文件的名称。\n1 ssh-add C:\\Users\\YOU/.ssh/id_ed25519 之后把id_ed25519.pub也就是公钥的内容copy到github上即可。\n1 2 cat ~/.ssh/id_ed25519.pub 并复制 登录github，Settings-\u0026gt;SSH and GPG Keys-\u0026gt;add SSH Key. ","date":"2024-02-17T16:01:18+08:00","image":"https://joker0ops.github.io/p/hugo-development-day2/30_hud2fc0782b828068ad19fdccc62bddd6d_475432_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/hugo-development-day2/","title":"Hugo建站指南——Day2"},{"content":"第一个Qt小程序 本篇开始即进入QT的开发环节，本节主要内容有QT PushButton的添加、QT 窗口编辑操作、QT 对象树及QT中的坐标系。\nQPushButton的创建 1. 查询assistant找到QPushButton的相关介绍 从图中说明我们可以看出，使用QPushButton需要包含头文件\u0026lt;QPushButton\u0026gt; ，同时需要widget模块的支持，由于我们使用的是QT5版本，因此QtCreator在项目构建时会自动包含widget模块（在使用QT4及以下版本时，需要在.pro文件中手动包含widget模块），而通过Inherits和Inherits By可得到QPushButton的继承路径：\n1 QObject -\u0026gt; QWidget -\u0026gt; QAbstractButton -\u0026gt; QPushButton -\u0026gt; QCommandLinkButton 2. 通过QPushButton类创建按钮并进行一系列初始化设置 打开mywidget.cpp（构建项目时自定义的类的源文件）并添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;mywidget.h\u0026#34; #include \u0026#34;ui_mywidget.h\u0026#34; // 按钮控件的头文件 #include\u0026lt;QPushButton\u0026gt; MyWidget::MyWidget(QWidget *parent): QWidget(parent), ui(new Ui::MyWidget) { ui-\u0026gt;setupUi(this); // 使用无参构造函数重新构建一个QPushButton对象并使btn指向该对象 QPushButton *btn = new QPushButton; // Question1: 添加的控件默认不会显示，需要调用show方法进行可视化，但为何生成的按钮并不依附于当前窗口内，而是重新打开一个窗口？ // btn-\u0026gt;show(); // 将当前窗口设置为父窗口，使得生成的按钮依附在当前窗口内部，并依赖父窗口的show方法显示按钮 btn-\u0026gt;setParent(this); // 设置并显示含文本的按钮 // Question2: 为什么我的中文显示乱码？ btn-\u0026gt;setText(\u0026#34;第一个按钮\u0026#34;); // 创建第二个按钮 // Question3: 为什么不能使用以下方法创建按钮对象？ // QPushButton btn2(\u0026#34;第二个按钮\u0026#34;,this); QPushButton *btn2 = new QPushButton(\u0026#34;第二个按钮\u0026#34;, this); // 移动btn2按钮 btn2-\u0026gt;move(100, 100); // 重置窗口大小 resize(600, 400); // 修改窗口标题 setWindowTitle(\u0026#34;这是一个窗口标题\u0026#34;); // 设置固定的窗口大小（防止用户使用鼠标拉伸窗口） setFixedSize(600, 400); // 设置按钮大小 btn2-\u0026gt;resize(100, 50); } MyWidget::~MyWidget() { delete ui; } 问题解答\nQuestion1： 由于当前新建按钮是基于一个新的Qt控件类——QPushButton，因此在调用show方法时调用的是QPushButton的show方法进行显示，在运行时会分别生成主窗口和按钮窗口（回顾main.cpp的内容）。因此我们在构建按钮时需要使用setParent方法为其指定父窗口，使其能够依附于主窗口进行显示。 Question2： 中文显示乱码是因为文件的默认编码不是utf-8，需要在上方菜单栏中选择工具-\u0026gt;选项-\u0026gt;文本编辑器-\u0026gt;Behavior找到文件编码，修改默认编码为utf-8后应用并确认即可 Question3： 在Qt中，对象模型一般基于动态内存分配而不是在栈上分配，即在创建对象时一般需要开发者在堆区为对象开辟内存空间，而不是将对象作为局部变量使用。这是因为局部变量存在于栈区，其生命周期在函数运行结束时截止，因此若使用QPushButton btn(\u0026ldquo;Text\u0026rdquo;, parent)的方法创建对象，那么该对象的生命周期仅仅是MiWidget构造函数的运行时间，当构造函数执行结束后，该对象也将会执行析构因此不会在运行时显示。而若使用new关键字在堆区创建对象，则其生命周期由开发者自行控制，在执行delete前该对象会一直存在。 对象树 从上文中我们可以看到，在创建控件对象时我们一般使用new关键字为新对象开辟内存空间，然而却并没有相对应的delete进行空间释放，这是因为Qt使用了对象树的技术使得程序运行结束后能够自行释放内存空间。\n对象树的定义： 当你创建一个QObject对象时，可以看到QObject的构造函数会接收一个QObject指针作为参数，这个参数就是parent（父对象指针）。由此，每当创建一个QObject对象时，Qt便会自动添加该对象到其父对象的children()列表，当父对象析构时，这个列表中的所有对象也会被析构。（注意：这里的父对象并不是继承意义上的父类，而是说该对象显示在（或依附于）哪个对象中。例如：一个按钮有一个QShortcut（快捷键）对象作为其子对象，当我们删除按钮时，这个快捷键也会被删除。 QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。当创建的对象在堆区时，如果指定的父对象所属类是QObject派生下来的类或其子类，那么派生下来的类可以无需管理释放操作，会将对象放入对象树，一定程度上简化了内存回收机制。 Qt中的坐标系 左上角为(0, 0)点 x以右为正方向，y以下为正方向，坐标向右向下逐渐增大 对于嵌套窗口，其坐标是相对于父窗口来说的(即坐标原点总是位于父窗口左上角) ","date":"2024-02-04T20:52:02+08:00","image":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_03/22_hu8c3a5b5f054fe6608239643744ee4034_521651_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_03/","title":"QT学习记录_03"},{"content":"Qt项目构建及项目结构说明 Qt Creator窗口介绍 欢迎界面 Projects：主要功能为管理会话、创建项目、打开项目 示例：可下载并参考一些官方做的Qt项目 教程：官方的Qt教程，需要翻墙观看 MarketPlace：一些可下载的Qt工具包 编辑界面：编辑当前项目代码 设计界面：通过可视化操作编辑当前界面UI Debug界面：代码调试 项目界面：设置并查看当前项目的一些配置信息 帮助界面：极为重要的界面，可以使用Filter学习自己不熟悉的类 Qt项目构建流程 欢迎界面的Projects模块点击New新建项目 在本次学习中，我们只涉及到Qt窗口应用的构建及开发，选择Application(Qt)-\u0026gt;Qt Widgets Application点击Choose 选择要创建项目的存储路径并输入项目名称，该步骤完成后会在存储路径生成两个目录，一个用于存放源文件，另一个用于存放构建及调试文件。（后续会讲解如何将这两个目录合并到一起） 选择项目的构建系统，在该步骤中，Qbs一般不会考虑，剩余两项构建系统的区别为：\nqmake：是Qt内置的构建系统，十分地简单方便，但扩展性和功能相对较低，初学阶段或小型项目选择qmake点击下一步即可。\ncmake：相对复杂，但扩展性和功能更加强大，适用于复杂度超过qmake处理能力的项目。 设置自己的窗口类，并勾选是否使用设计界面编辑窗口，其中类名可以自由指定，QWidget是QMainWindow和QDialog的父类。 QWidget是最简单的交互窗口，QMainWindow除了窗口外多了菜单栏、状态栏等等，QDialog是对话框（包含确认按钮、取消按钮等，类比当前窗口） 选中Generate form后会启用设计界面。指定类名后，下面的基类名、头文件、源文件等会自动跟随自定义类名进行命名。配置完成后点击下一步。 选择是否为Qt项目添加英文自动翻译工具，一般不需要因此暂时忽略。 选择构建项目所使用的编译环境，我是64位机因此选择第二个选项，如要获得更多的系统可移植性可选择32位进行项目构建。 完成项目构建，从要添加的文件中可了解到项目的构建路径以及项目所包含的项目文件。\nmain.cpp是主程序入口\nmywidget.cpp是个人定制的窗口类\nmywidget.h是个人定制的窗口类的头文件\nmywidget.ui是个人定制的窗口类的可视化设计文件，它本质上是一个标准XML格式的文本，需要通过uic工具将其转换为项目中可用的ui_*.h头文件，使用时ui是一个指向自定义界面类的指针（后面一般跟着控件名）例如ui文件中有一个叫textEdit的QTextEdit组件，你就可以通过ui-\u0026gt;textEdit来访问这个文本框\nQtStudy_Day01.pro是工程文件，是qmake(or cmake)自动生成的用于生成makefile的配置文件，可以通过该文件直接打开项目。\n基础main函数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 自己新建的窗口类 #include \u0026#34;mywidget.h\u0026#34; // 包含一个应用程序类的头文件 #include \u0026lt;QApplication\u0026gt; // main函数主要执行一些初始化的工作，然后将控制权转交给Qt库，然后Qt库通过事件向程序告知用户行为。 // 程序入口，argc用来接收命令行参数的个数，argv用来接收命令行参数的数组 int main(int argc, char *argv[]) { // a是应用程序类QApplication实例化出来的对象，每个Qt程序有且仅有一个 QApplication a(argc, argv); // 使用自定义的窗口类MyWidget构建一个窗口对象w，MyWidget是继承自父类QWidget的子类 MyWidget w; // 构建窗口对象w后默认不会显示窗口，必须调用show方法进行显示 w.show(); // 让应用程序对象进入消息循环，即main函数将控制权转交给Qt // 在exec()函数中，Qt接收处理用户和系统的事件并将它们传递给适当的窗口部件 return a.exec(); /* 类比: while(true){ if(点击叉号) break; else{ 捕获动作 continue; } } */ } .pro文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 一般情况下不要轻易改动.pro文件 # Qt包含的模块：core和gui（Qt5以上才将Qt Widget模块从gui模块分离出来） QT += core gui # Qt版本号大于4，Qt新增了Widget模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets # 工程配置和编译的参数，允许C++11语法 CONFIG += c++11 # 项目编译后生成的可执行文件的文件名（可修改），在项目调试目录中 TARGET = QtStudy_Day01 # 使用Qt的application模板，告诉qmake为这个应用程序生成哪种makefile TEMPLATE = app # 预定义预处理符号 DEFINES += QT_DEPRECATED_WARNINGS # 指定来自moc的所有中间文件放置的目录（含Q_OBJECT宏的头文件转换为标准.h文件的存放目录） MOC_DIR += \\ # 指定多有中间文件.o(.obj)放置的目录 OBJECTS_DIR += \\ # UIC将ui转化为头文件所存放的目录 UI_DIR += \\ # 指定编译项目时应该搜索的文件夹 INCLUDEPATH += \\ # 指定最终文件生成的目录 DESTDIR += \\ # You can make your code fail to compile if it uses deprecated APIs. # In order to do so, uncomment the following line. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 # 源文件包含main.cpp以及mywidget.cpp文件 SOURCES += \\ main.cpp \\ mywidget.cpp # 头文件包含mywidget.h文件 HEADERS += \\ mywidget.h # 设计文件包含mywidget.ui文件 FORMS += \\ mywidget.ui # Default rules for deployment. # 目标文件地址 qnx: target.path = /tmp/$${TARGET}/bin else: unix:!android: target.path = /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS += target 自定义窗口头文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 防止头文件被重复引用，如果没有该自定义头文件则执行#define MYWIDGET_H进行头文件包含操作。 #ifndef MYWIDGET_H #define MYWIDGET_H // 包含窗口类头文件 #include \u0026lt;QWidget\u0026gt; // 定义自定义窗口类的命名空间Ui，声明Ui命名空间下的Widget类 QT_BEGIN_NAMESPACE namespace Ui { class MyWidget; } QT_END_NAMESPACE // 让自定义窗口类继承QWidget类以使用show等方法 class MyWidget : public QWidget { // 宏，允许类中使用信号和槽的机制以及元对象系统服务，必须限定为私有访问权限 Q_OBJECT public: // 声明有参构造函数并提供默认值，使用该默认值时将调用父类QWidget的有参构造函数 MyWidget(QWidget *parent = nullptr); // 声明默认析构函数 ~MyWidget(); private: // 创建Ui::Widget类型的指针，用于操作ui界面及其控件。 Ui::MyWidget *ui; }; #endif // MYWIDGET_H 自定义窗口源文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;mywidget.h\u0026#34; #include \u0026#34;ui_mywidget.h\u0026#34; // 有参构造函数的定义：声明时使用了默认参数，定义时则不再使用 /* * MyWidget有参构造函数的定义，并使用初始化列表对其进行初始化： * 已知MyWidget继承自QWidget，令QWidget *parent = parent，然后对MyWidget进行初始化。 * 令ui = new Ui::MyWidget，使得ui指针指向新创建的Ui命名空间内的MyWidget类型对象，通过这个对象可以访问和操作MyWidget的用户界面元素。 */ MyWidget::MyWidget(QWidget *parent): QWidget(parent), ui(new Ui::MyWidget) { // 为ui对象传入当前窗口对象指针，将当前窗口对象与其ui绑定 ui-\u0026gt;setupUi(this); } // 析构函数的定义 MyWidget::~MyWidget() { delete ui; } Qt Creator快捷键 Key 说明 ctrl + / 注释 ctrl + r 运行 ctrl + b 编译 ctrl + MouseUp/MouseDown 字体缩放 ctrl + f 查找 ctrl + shift + ↑/↓ 整行移动 F1 帮助文档（或者直接运行Qt Assistant） ctrl + i 自动对齐 F4 同名之间 .h和 .cpp自由切换 ","date":"2024-02-04T20:51:56+08:00","image":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_02/20_hue8028801c9f73dd91eba9fc177c5fd74_708628_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_02/","title":"QT学习记录_02"},{"content":"QT概述 QT简介：跨平台C++图形用户界面应用程序框架，完全面向对象，易扩展且允许组件编程。 版本及兼容性： QT商业版：相较开源版本多提供了商业有效期内的免费升级和技术支持服务。 QT开源：与商业版相同功能，在GNU通用公共许可下发布的免费版本。 Windows全平台、Linux、Mac全平台、嵌入式Linux、iOS、Android、WP QT入门资源推荐 QT入门到进阶书籍（建议从Qt5开始学） 《QT Creator 快速入门 霍亚飞》：必买 《QT及QT Quick开发实战精解》：5个实用的QT实例以及QT Quick技术介绍 《Qt5.9 C++开发指南》：必买 《Qt5开发及实例》：以QT5作为平台，每个章节用一个小实例介绍QT5开发的各个方面，最后通过三个大实例系统介绍QT5综合应用开发。 《QT5编程入门》：qml推荐书籍 进阶 《C++ GUI QT4编程》 《QT高级编程》 OpenCV3和Qt5计算机视觉应用开发 推荐的QT论坛+个人博客+网站 名称 网址 qtcn http://www.qtcn.org 豆子的空间 [DevBean Tech World](DevBean Tech World) yafeilinux qt qml linux 嵌入式 教程! 一去二三里 http://blog.csdn.net/liang19890820 乌托邦2号 http://blog.csdn.net/taiyang1987912 foruok http://blog.csdn.net/foruok jason http://blog.csdn.net/wsj18808050 朝十晚八 [朝十晚八 - 博客园](朝十晚八 - 博客园) BIG_C_GOD http://blog.csdn.net/big_c_god 公孙二狗 https://qtdebug.com/qtbook 雨田哥 https://blog.csdn.net/ly305750665 郑天佐 https://blog.csdn.net/zhengtianzuo06 寒山-居士 https://blog.csdn.net/esonpo feiyangqingyun https://blog.csdn.net/feiyangqingyun 前行中小猪 http://blog.csdn.net/goforwardtostep 涛哥的知乎专栏 Qt进阶之路 Qt君 https://blog.csdn.net/nicai_xiaoqinxi Qt老外视频教程 [哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili](哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili) Qt维基补充文档 Qt Wiki Qt源码查看网站 qt5/ Source Tree - Woboq Code Browser Qt官方下载地址 Index of / Qt国内镜像下载地址 [Index of /qt/](Index of /qt/) Qt优点 跨平台 接口简单 一定程度上简化了内存回收程序 Qt成功案例 Linux的一种桌面环境：KDE WPS Office Skype 网络电话 Google Earth 谷歌地图 VLC 多媒体播放器 VirtualBox虚拟机软件 Qt版本 商业版 为商业发行版Qt，并且提供商业有效期内的免费升级和技术支持服务 开源LGPL版本 提供了与商业版本同样的功能，但没有免费升级和技术支持服务 ","date":"2024-02-04T20:51:42+08:00","image":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_01/19_hu279ce5e96b74c838a255ccc4e759ad22_706904_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_01/","title":"QT学习记录_01"},{"content":"写在前面 大学期间曾经尝试了许多中博客框架，从最初的WordPress到后来的Hexo再到使用Django搭建包含管理员后台系统的完整博客网站，但都没能够长时间使用，总感觉从前期开发到后期部署会出现各种各样的问题。于是我一直想要寻找一个能够快速构建、方便部署并能够让我在更新过程中不断对其进行完善的博客框架；直到Git Pages的出现，让静态网站框架搭建博客有了无与伦比的优势，我也开始搜集各种教程搭建博客，并最终确定了Hugo这一优秀的框架。\n本篇文章作为Hugo建站的系列文章，将详细记录我在建站过程中的建站流程、遇到的困难以及解决方法，希望能给读者朋友们带来一定的帮助。\n注：我是在Ubuntu 20.04环境下搭建的，在一些细节方面不同系统可能存在一些差异，见谅。\n准备阶段 由于Hugo是基于Go语言开发的静态网页框架，并且需要我们部署到Github上来允许其他人的访问，因此我推荐你预先安装以下三款软件。\n1 2 3 1. Go # 为Hugo提供更多的Go语言支持 2. Git # 实现与Github的远程拉取及推送服务 3. DartSass # 实现Hugo中Sass语法与css语法的转换 Go Linux 删除旧版本的Go，一般是在 /usr/local/go 中，然后下载官方的tar包并解压到 /usr/local 中: 1 $ rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.21.6.linux-amd64.tar.gz 以上指令可能需要管理员身份或添加sudo语句来执行，记住不要将文件解压到一个已经存在的go目录，可能会导致Go无法正常运行。\n将 /usr/local/go/bin 添加到环境变量中（将以下语句写入 $HOME/.profile 或者 /etc/profile ） 1 export PATH=$PATH:/usr/local/go/bin 添加该行语句并保存退出后记得使用source指令更新系统环境变量\n在命令行中输入以下语句来检验go的安装及版本号 1 $ go version Windows 下载好相应的MSI文件后根据提示依次执行安装程序 重新打开命令行输入 go version 验证安装。 Git Linux(System Based on Debian) 1 sudo apt install git-all Windows 1 直接按照官网提示进行安装即可。 DartSass Linux(System Based on Debian) 进入Dart-Sass Release下载相应的安装包 解压到 /usr/local 中 1 sudo tar -zxvf ~/Downloads/dart-sass-1.52.1-linux-x64.tar.gz -C /usr/local 以上指令可能需要管理员身份或添加sudo语句来执行，记住不要将文件解压到一个已经存在的dart-sass目录，可能会导致Dart无法正常运行。\n将 /usr/local/dart-sass 添加到环境变量中（将以下语句写入 $HOME/.profile 或者 /etc/profile ） 1 export PATH=$PATH:/usr/local/dart-sass 添加该行语句并保存退出后记得使用 source 指令更新系统环境变量\n在命令行中输入以下语句来检验go的安装及版本号 1 $ sass --version 安装Hugo 进入Hugo Release的下载页面，下载对应的Hugo-extended版本的deb包(注意！！！一定要安装hugo-extended版本，否则有些主题会出现不支持的问题) 输入以下命令进行安装和验证 1 2 sudo dpkg -i 你的安装包的名字.deb hugo version 若命令行中出现extended字样，说明Hugo已被正确安装。\n使用Hugo新建站点并引入主题 首先需要创建一个新的个人站点 1 hugo new site blog blog就是博客站点所在的目录，即站点根目录，创建后站点目录结构如下： 1 2 3 4 5 6 7 8 9 10 11 archetypes assets content data i18n layouts public resources static themes config.toml 简单介绍下Hugo根目录下各个文件目录的作用： archetypes 存放创建文件时使用的模板，可以自定义front matter属性。 assets 存放需要被Hugo Pipes处理的文件，且只有使用了.Permalink或者.RelPermalink的文件才能被发布到public目录。 注意，默认不会创建assets目录。 content 存放的各种md文件用于部署站点，该目录下可以自行创建若干个子目录来便于对文章进行分类，这些子目录被称为section。 data 目录存放的是用于定义变量的模板文件，相当于Java里的常量类，这些文件有JSON、 YAML或者TOML三种格式，会在生成站点时被使用到。一般用不到该功能，具体用法可以参考：data templates i18n 存放博客所需的各种语言包 layouts 目录存放的模板文件用于渲染html页面，模板里可以定义不同页面的html代码。 public 目录用于存放站点执行hugo -D指令后生成的静态页面文件，提交时只需将此目录中的文件推送到远程库中即可 resources 目录用于缓存某些文件来提高生成效率。 注意，默认不会创建resources目录。 static 目录存放的是静态内容：图片、CSS、JavaScript等。 themes 目录用于存放Hugo支持的主题文件 config.toml 是配置文件，可以有JSON、 YAML或者TOML三种格式，默认使用根目录下的config.toml、config.yaml或config.json中的某一个。可以通过\u0026ndash;config来配置读取一个或多个配置文件，如：hugo \u0026ndash;config a.toml,b.toml,c.toml。 注意，默认不会创建config目录。 进入站点目录，下载主题到站点theme文件夹的相应主题目录下： 1 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 进入themes/hugo-theme-stack/exampleSite目录，复制所有内容到站点目录并进行替换： 1 2 cd themes/hugo-theme-stack/exampleSite sudo cp * ../../../ 切换到站点目录，使用如下指令即可新建博文并且在本地运行博客网站： 1 2 3 hugo new post/我的第一篇博客 hugo -D hugo server -D 注：新建博文后博文头部front matter中draft: true表明该文章是草稿，如果在启用服务时不指定参数-D或\u0026ndash;buildDrafts，或者在配置文件config.toml中配置buildDrafts = true，则会在生成文章时忽略草稿。如果不想指定该参数就生成文章，需要改为draft: false或者将其删去！！！ 另注：新建博文后front matter中一定记着填写一个独一无二的标签，不是为了方便自己阅读，而是能够保证Hugo在生成静态页面文件时不至于将多篇博文错认成一篇博文从而导致一篇博文多次发表的情况！！！\n总结 以上就是Hugo搭建Stack主题博客的基础部分，下期将会讲解如何将个人博客推送到GitPages以允许博客的外部访问。\n","date":"2024-02-02T15:19:35+08:00","image":"https://joker0ops.github.io/p/hugo-development-day1/82_hub28da18d4871e87a3433ed7bebc8e373_795065_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/hugo-development-day1/","title":"Hugo建站指南——Day1"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://joker0ops.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://joker0ops.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://joker0ops.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","image":"https://joker0ops.github.io/p/math-typesetting/87_hu1c805f75d7d3cbd4969b0834385286cd_320605_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://joker0ops.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://joker0ops.github.io/p/emoji-support/","title":"Emoji Support"}]