[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 import json # 文件操作 \u0026#34;\u0026#34;\u0026#34; 关键字with使得Python在用户不需要访问文件后将其关闭，这比单纯地通过open()和close()函数打开和关闭文件更加稳妥 如果使用close()关闭文件，那么如果程序出现Bug导致close()函数未能执行，文件将不会关闭 如果过早地调用close()，可能会使得使用文件时已经关闭，导致更多错误 但是使用with关键字时，open()返回的文件对象只在with代码块内部可用 \u0026#34;\u0026#34;\u0026#34; with open(\u0026#34;LoadingFile.txt\u0026#34;) as file_object: # 函数open()接收一个文件位置+文件名并返回一个表示文件的对象，Python将该对象命名为file_object contents = file_object.read() # 使用read()方法读取文件全部内容(包括空格和制表符)会返回一个长字符串，且到达文件末尾时还会返回一个空字符串 print(contents.rstrip()) # 这个多出来的空字符串会以空行的形式展现，需要使用rstrip()方法消除右空格 \u0026#34;\u0026#34;\u0026#34; 在显示文件路径时，Windows系统使用反斜杠\u0026#39;\\\\\u0026#39;，而Linux系统使用斜杠/ Windows系统示例：C:\\\\path\\\\to\\\\file.txt Linux系统示例：/home/joker/code/python.txt 在open函数中使用绝对路径和相对路径都可以 \u0026#34;\u0026#34;\u0026#34; with open(\u0026#34;.\\\\LoadingFile.txt\u0026#34;) as Pi_Object: # 对文件实行逐行读取 for item in Pi_Object: print(item.rstrip()) # 这种操作会使得每行末尾都有两个换行符，一个来自文件本身，一个来自print()函数，这些换行符都可以用strip类方法消除 # 创建一个包含文件各行内容的列表 lines = Pi_Object.readlines() # readlines()方法读取文件中的每一行，并将其存储到一个列表中，最后赋值给lines pi_string = \u0026#34;\u0026#34; # 将各行加入pi_string变量 for line in lines: # 使用strip方法去除所有空格 pi_string += line.strip() # 最后根据需要也可以使用int()或float()对字符串进行转换 print(pi_string) print(len(pi_string)) # 大文件处理 filename = \u0026#34;pi_million_digits.txt\u0026#34; with open(filename) as file_object2: contents = file_object2.readlines() PI = \u0026#34;\u0026#34; for line in contents: PI += line.strip() print(f\u0026#34;{PI[:50]}...\u0026#34;) print(len(PI)) birthday = input(\u0026#34;Enter your birthday, in the form mmddyy: \u0026#34;) if birthday in PI: # 注：空串是任何字符串的子串 print(\u0026#34;Your birthday appears in the first million digits of pi!\u0026#34;) else: print(\u0026#34;Your birthday doesn\u0026#39;t appears in the first million digits of pi!\u0026#34;) # replace方法的使用： message = \u0026#34;I really like dogs.\u0026#34; message.replace(\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;) # 替换字符串中所有的dog子串 print(message) # 写入文件 filename = \u0026#34;programming.txt\u0026#34; with open(filename, \u0026#39;w\u0026#39;) as file_object3: # 以写入模式打开文件，当文件不存在时，函数open()将自动创建文件 # 用写入模式打开文件时要小心，因为若指定的文件已经存在，Python将在返回文件对象前清空文件内容 file_object3.write(\u0026#34;I love programming.\\nI love creating new games.\\n\u0026#34;) # 函数write()不会在写入的文本末尾自动添加换行符，需要自行添加，否则两句会独占一行 \u0026#34;\u0026#34;\u0026#34; 文件打开模式： \u0026#39;w\u0026#39;：写入模式 \u0026#39;r\u0026#39;：只读模式 \u0026#39;a\u0026#39;：附加模式 \u0026#39;r+\u0026#39;：读写模式 如果省略了模式实参，Python将会以默认的只读模式打开文件 注意：Python只能将字符串写入文本文件。如要存储数值数据，需要先用str()将其转换为字符串格式 \u0026#34;\u0026#34;\u0026#34; with open(filename, \u0026#39;a\u0026#39;) as file_object4: # 以附加模式打开文件，当文件不存在时，函数open()将自动创建文件 # 以附加模式打开文件时，Python不会在返回文件对象前清空文件内容，而是将写入文件的行添加到文件末尾 file_object4.write(\u0026#34;I also love finding meaning in large datasets.\\n\u0026#34;) file_object4.write(\u0026#34;I love creating apps that can run in a browser.\\n\u0026#34;) # Python每产生一个错误都会创建一个异常对象，异常是通过try-except代码块处理的，使用该代码块时即使出现错误也不会traceback而是继续运行 a = input(\u0026#34;Please input a number as Division: \u0026#34;) b = input(\u0026#34;please input a number as b: \u0026#34;) try: print(int(a) / int(b)) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by zero \u0026#34;) \u0026#34;\u0026#34;\u0026#34; 另一种结构： try: 尝试 except 异常对象: 异常处理 else: 如果未发现异常将会执行的程序 \u0026#34;\u0026#34;\u0026#34; def count_words(filename): \u0026#34;\u0026#34;\u0026#34;计算一个文件大致包含多少单词\u0026#34;\u0026#34;\u0026#34; try: with open(filename, encoding=\u0026#34;utf-8\u0026#34;) as f: # 若系统默认编码和文件编码不一致，则必须使用encoding参数 contents = f.read() except FileNotFoundError: print(f\u0026#34;Sorry, the file {filename} doesn\u0026#39;t exist.\u0026#34;) # pass # 该处也可以换成pass，代表静默异常——即什么都不做 else: words = contents.split() # 使用方法split来根据一个字符串创建一个单词列表 num_words = len(words) print(f\u0026#34;The file {filename} has about {num_words} words.\u0026#34;) for item in range(1, 11): filename = input(\u0026#34;Please input a filename: \u0026#34;) count_words(filename) # JSON模块：用于对文件存储或加载数据，还可以使用JSON在Python程序之间分享数据 numbers = [2, 4, 6, 7, 9, 10] # 若numbers列表使用range生成，需要使用list()转义：numbers = list(range(1, 11)) filename = \u0026#39;numbers.json\u0026#39; with open(filename, \u0026#39;w\u0026#39;) as f: json.dump(numbers, f) with open(filename, \u0026#39;r\u0026#39;) as f: numbers2 = json.load(f) print(numbers2) # JSON应用实例 def get_stored_username(): \u0026#34;\u0026#34;\u0026#34;如果已经存储了用户名，就获取它\u0026#34;\u0026#34;\u0026#34; filename = \u0026#34;username.json\u0026#34; try: with open(filename) as f: username = json.load(f) except FileNotFoundError: return None else: return username def get_new_username(): \u0026#34;\u0026#34;\u0026#34;提示用户输入用户名\u0026#34;\u0026#34;\u0026#34; username = input(\u0026#34;Please input your name: \u0026#34;) filename = \u0026#34;username.json\u0026#34; with open(filename, \u0026#39;w\u0026#39;) as f: json.dump(username, f) print(f\u0026#34;We will remember you when you come back, {username}.\u0026#34;) return username def greet_user(): \u0026#34;\u0026#34;\u0026#34;问候用户，并指出其名字\u0026#34;\u0026#34;\u0026#34; username = get_stored_username() if username: print(f\u0026#34;Welcome back, {username}!\u0026#34;) else: username = get_new_username() greet_user() ","date":"2024-03-14T21:10:28+08:00","image":"http://localhost:1313/p/pythonbasic07/38_hu144f3be509ee1c6ddf2909d358951aca_1445473_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic07/","title":"Python基础 07 文件操作"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from random import randint, choice # 常见Python标准库，随机数标准库，但创建安全相关的项目时不要使用random # 类，定义中使用首字母大写的单词表示类，类定义时名称后没有圆括号表示没有继承等操作，是从空白创建一个类 class Dog: def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性name和age 这里的__init__()是一个类默认方法\u0026lt;类中的函数\u0026gt;，每当根据Dog类创建新实例\u0026lt;对象\u0026gt;时，Python都会自动运行它。 在这个方法的定义中，形参self必不可少，而且必须位于其他形参的前面，每次创建此类的实例时，该方法都会自动运行此 方法并传入实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。 每当根据Dog类创建实例时，都只需要给最后两个形参name和age提供值 以self为前缀的变量可供类中的所有方法使用，可以通过类的任何实例来访问，称为属性self.XXX \u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟小狗收到指令时蹲下\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} sat down!\u0026#34;) def roll_over(self): \u0026#34;\u0026#34;\u0026#34;模拟小狗收到命令时打滚\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} rolled over!\u0026#34;) my_dog = Dog(\u0026#34;Willie\u0026#34;, 6) # 创建实例时调用__init__() print(f\u0026#34;My Dog\u0026#39;s name is {my_dog.name}\u0026#34;) print(f\u0026#34;My Dog\u0026#39;s age is {my_dog.age}\u0026#34;) # Python先找到实例my_dog，再查找与该实例相关联的属性name # 在Dog类中引用这个属性时，使用的是self.name my_dog.sit() my_dog.roll_over() # 导入类： # from car import Car, ElectricCar 从一个模块中导入多个类，但这种方法容易与当前文件中的名称发生冲突，需要注意头部导入的模块 # import car 这种方法导入整个模块，再使用句点表示法访问需要的类，用到模块中的类时均需要包含模块名，因此不会发生冲突 # from module_name import * 不推荐使用这种方式 # 有时候，需要将类分散到多个模块中，以免模块太大或在同一个模块中存储不相关的类，也可以在引入模块后用as对模块命名以区别 # Python标准库 print(randint(1, 10)) # 随机返回一个位于1~10之间包含的整数 arrays = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;z\u0026#39;] print(choice(arrays)) # 以列表或元组作为参数，随机返回其中一个元素 # 驼峰命名法 \u0026#34;\u0026#34;\u0026#34; 1. 类名中的每个单词首字母都大写，并且单词之间不使用下划线。实例名和模块名都使用小写并在单词之间加上下划线 2. 对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式规定 每个模块也都应该包含一个文档字符串，并对其中的类的用途进行描述 \u0026#34;\u0026#34;\u0026#34; ","date":"2024-03-14T21:09:42+08:00","image":"http://localhost:1313/p/pythonbasic06/37_hu0c079b41d74169b6af3ee1b4d0a4c00c_3362922_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic06/","title":"Python基础 06 面向对象"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 message = input(\u0026#34;Please input a number: \u0026#34;) # input函数能够让程序暂停等待用户输入一些文本，并将该文本理解为字符串 # 当获取到用户输入后将字符串赋值给message变量，同时input函数会接收一个参数用于要向用户显示的提示 # while循环 unconfirmed_users = [\u0026#39;alice\u0026#39;, \u0026#39;brain\u0026#39;, \u0026#39;candace\u0026#39;] confirmed_users = [] while unconfirmed_users: value = unconfirmed_users.pop() confirmed_users.append(value) print(confirmed_users) # 删除包含特定值的所有列表元素 pets = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;goldfish\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;cat\u0026#39;] while \u0026#39;cat\u0026#39; in pets: pets.remove(\u0026#39;cat\u0026#39;) print(pets) # 函数 def display_message(title): # 形参 print(f\u0026#34;Hello, {title.title()}\u0026#34;) display_message(\u0026#34;mike\u0026#34;) # 实参 def describe_pet(animal_type, pet_name): print(f\u0026#34;This is {pet_name.title()}, it is a {animal_type}.\u0026#34;) # 位置实参：基于实参的顺序将函数调用中的每个实参都关联到函数定义中的一个形参。 describe_pet(\u0026#34;dog\u0026#34;, \u0026#34;Jake\u0026#34;) # 关键字实参：在实参中将名称和值直接关联起来，所以向函数传递实参时不会混淆。不需要考虑顺序。 describe_pet(animal_type=\u0026#34;dog\u0026#34;, pet_name=\u0026#34;mike\u0026#34;) # 当使用形参并给形参指定默认值时，若在函数调用时给形参提供实参，则使用实参值，若不指定则使用默认值 def function(def_num=1): print(def_num) function(2) # 返回字典\u0026amp;让函数形参变成可选的 def build_person(firs_name, last_name, age=None): # 这里将age的默认值设置为None(表示变量没有值)使其变成可选的参数，在条件测试中，None相当于False \u0026#34;\u0026#34;\u0026#34;返回字典，其中包含有关一个人的信息\u0026#34;\u0026#34;\u0026#34; person = {\u0026#34;first_name\u0026#34;: firs_name, \u0026#34;last_name\u0026#34;: last_name} if age: person[\u0026#34;age\u0026#34;] = age return person He = build_person(\u0026#34;Jimi\u0026#34;, \u0026#34;hendrix\u0026#34;, 17) print(He) # 传递列表并在函数中修改列表 def exchange_items(unworked_missions): \u0026#34;\u0026#34;\u0026#34; : param unworked_missions: the missions waiting for print : param worked_missions: the missions which was printed : return: worked_missions \u0026#34;\u0026#34;\u0026#34; worked_missions = [] while unworked_missions: item = unworked_missions.pop() print(f\u0026#34;Mission {item} has worked.\u0026#34;) worked_missions.append(item) return worked_missions def show_missions(worked_missions): print(\u0026#34;This is missions to show:\u0026#34;) for item in worked_missions: print(item) unworked_missions1 = [\u0026#34;Halo\u0026#34;, \u0026#34;insurgency\u0026#34;, \u0026#34;CS\u0026#34;, \u0026#34;Batman_Arkham_Knight\u0026#34;] # 定义成unworked_missions1会显示与形参命名重复 worked_missions1 = exchange_items(unworked_missions1) # worked_missions = exchange_items(unworked_missions[:]) 在实参中使用复制切片的方式防止函数对实际列表进行修改，在这里函数修改的只是复制的列表 # 虽然这种方式可以保留原始列表中的内容，但是这种方式会浪费内存和时间来创建副本，在问题容量较大时不建议使用 show_missions(worked_missions1) # 传递任意数量的实参 # 可以使用*号来创建能够接收任意数量实参的形参元组，但要区分是使用位置实参还是关键字实参 # 位置实参 def make_pizza(size, *topping): # 在函数调用时，size接收传入的第一个实参，然后将其余所有值都存储在元组toppings中 print(f\u0026#34;Make a pizza of {size}-inch size, and the tops is:\u0026#34;) for item in topping: print(f\u0026#34;-{item}\u0026#34;) # print(topping) make_pizza(5, \u0026#34;delicious\u0026#34;, \u0026#34;tasty\u0026#34;, \u0026#34;salty\u0026#34;) # 关键字实参 def user_profile(first_name, last_name, **user_info): \u0026#34;\u0026#34;\u0026#34; 形参**user_info的两个星号使得Python创建一个名为user_info的空字典，并存储从实参中传入的所有键值对 : param first_name: The first name of a man : param last_name: The last name of a man : param user_info: Other information of a man : return: user_info \u0026#34;\u0026#34;\u0026#34; user_info[\u0026#34;first_name\u0026#34;] = first_name user_info[\u0026#34;last_name\u0026#34;] = last_name user_info[\u0026#34;location\u0026#34;] = \u0026#34;England\u0026#34; # 函数中的优先级高，函数中修改字典值可使得实参无效 print(user_info[\u0026#34;field\u0026#34;]) return user_info user_profile = user_profile(\u0026#34;albert\u0026#34;, \u0026#34;einstein\u0026#34;, location=\u0026#34;princeton\u0026#34;, field=\u0026#34;physics\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 函数调用结果会返回一个未排序的名为user_info的字典，多余的实参将以键值对的形式存储在字典中 \u0026#34;\u0026#34;\u0026#34; print(user_profile) # 模块调用方式 # 调用整个模块并使用模块内任意的函数和变量 # import module_name # module_name.function_name() import Module print(Module.compare(1, 2)) print(Module.c) # 导入特定的函数 # from module_name import function_name1, function_name2, function_name3... # function_name1() from Module import compare print(compare(3, 4)) # 使用as给函数或模块指定别名 # import module_name as XXX # from module_name import function_name as XXX import Module as Md from Module import compare as cp print(Md.printc()) print(cp(5, 6)) # 导入模块中所有函数 # from module_name import * from Module import * print(compare(7, 8)) print(printc()) ","date":"2024-03-14T21:09:27+08:00","image":"http://localhost:1313/p/pythonbasic05/33_huae91757ed3f520b8791a7ce2bd19e0b6_883257_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic05/","title":"Python基础 05 函数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # Python中的字典元素以键值对的形式存储，类似于C中的结构体，每一个键都与一个值相关联，与键相关联的值可以是 # 字典使用的第一种类型：存储同一类对象的不同信息 alien = { \u0026#34;color\u0026#34;: \u0026#34;green\u0026#34;, \u0026#34;points\u0026#34;: 5 } # 访问字典中的值 print(alien[\u0026#39;color\u0026#39;]) # 字典是一种动态结构，可以随时添加键值对，直接使用赋值的方式指定字典名，键名和值即可 alien[\u0026#34;method\u0026#34;] = \u0026#34;post\u0026#34; print(alien) # 字典直接打印 # 在使用字典来存储用户提供的数据或在编写能自动生成大量键值对的代码时，通常需要先定义一个空字典 alien_0 = {} # 若是修改字典的值，直接按照赋值的方式修改即可 # 对于不再使用的信息，可以使用del语句，指定字典名和要删除的键来删除 del alien[\u0026#34;method\u0026#34;] print(alien) # 对于字典的另一种使用方式，即存储不同对象的同一类信息 favorite_languages = { \u0026#34;jen\u0026#34;: \u0026#34;Python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#39;C\u0026#39;, \u0026#34;edward\u0026#34;: \u0026#34;ruby\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;Python\u0026#34; } # 使用随机存取方式访问字典元素时，若指定的键不存在会报错，可以使用get方法指定任意键，当该键不存在时返回一个指定的默认值（可选） # 若没有指定可选的测试值时，get将返回None point_language = favorite_languages.get(\u0026#34;Jack\u0026#34;, \u0026#34;No such key\u0026#34;) # 使用for循环迭代器的方式遍历字典 for key, value in favorite_languages.items(): # 方法items()返回一个键值对列表，for循环将依次将两个列表中的元素分别赋值给key和value两个变量 print(f\u0026#34;\\nkey: {key}\u0026#34;) print(f\u0026#34;value: {value}\u0026#34;) # 遍历字典中的所有键而不遍历值 for key in favorite_languages.keys(): print(key) # 也可以使用当前key变量来访问键key所对应的value print(favorite_languages[key]) # keys()方法与items方法类似，但只是返回一个键的列表 if \u0026#34;sarah\u0026#34; in favorite_languages.keys(): print(\u0026#34;search successfully!\u0026#34;) # 可以在for循环遍历之前对字典使用sorted函数进行临时排序 # 如果只想获取字典中的所有值，可以使用values()方法返回一个值的列表 for value in favorite_languages.values(): print(value) print(\u0026#34;\\n\u0026#34;) # 可以发现，这种方法获取值是不会剔除掉重复项的，可以使用集合set函数，使得列表中的元素独一无二 for value in set(favorite_languages.values()): print(value) # 对于普通集合可以使用花括号来定义，其与字典的区别是集合是单一元素，而字典是键值对，而且集合不会以特定的顺序存储元素 set1 = {\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;1\u0026#39;} print(set1) ","date":"2024-03-14T21:08:47+08:00","image":"http://localhost:1313/p/pythonbasic04/27_hua0a87597e90d2a983f5c4828e691e445_427171_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic04/","title":"Python基础 04 字典"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # if语句的使用 print(1 == 1) # 首先要了解比较运算符的返回值，如果是True就会被if处理，False则会被if忽略 print(\u0026#39;abc\u0026#39; == \u0026#39;ab\u0026#39;) str1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;hello\u0026#34; if str1 != str2: # 逻辑表达式中可以直接判断两个字符串是否相等 print(\u0026#34;The string is not same\u0026#34;) num1 = 1 num2 = 1 if num1 == num2 and str1 == str2: print(\u0026#34;yes\u0026#34;) elif num1 == num2 or str1 == str2: print(\u0026#34;right\u0026#34;) else: print(\u0026#34;no\u0026#34;) # 对列表中的值进行查询判断 # 检查特定值是否包含在列表中： cars = [\u0026#34;bmw\u0026#34;, \u0026#34;Audi\u0026#34;, \u0026#34;Bench\u0026#34;, \u0026#34;Toyota\u0026#34;] if \u0026#34;bmw\u0026#34; in cars: print(True) # 检查特定值是否不包含在列表中： elif \u0026#34;Audi\u0026#34; not in cars: print(False) else: print(True) # 确定列表不是空的，在if语句中将列表名作为条件表达式时，Python将在列表中至少包含一个元素时返回True，并在列表为空时返回False trip = [] if trip: print(True) else: print(False) ","date":"2024-03-14T21:08:29+08:00","image":"http://localhost:1313/p/pythonbasic03/24_hu803bcfd6111a2fbf769f32597e09a59c_622219_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic03/","title":"Python基础 03 选择结构"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 # 在Python中，使用方括号表示列表，并用逗号分隔其中的元素 Characters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;] print(Characters) # 访问列表元素，列表支持随机访问控制，也可以通过负数索引访问倒数第x个元素，例如： print(Characters[-1]) # 在列表中添加元素，除了重新定义列表外，还可以通过以下方式： Characters.append(\u0026#39;o\u0026#39;) # 在列表末尾添加新元素 Characters.insert(0, \u0026#39;firstly\u0026#39;) # 在第一个位置插入firstly，原来的0号位及之后的元素统一向后移动一位 print(Characters) del Characters[0] # 删除某个位置的元素 print(Characters) a = Characters.pop() # 可以弹出列表尾的元素，列表中原列表尾元素被删除并赋值到e # 如果想用pop删除某一位序的元素，则在参数中写入元素的位置 b = Characters.pop(0) # 根据元素值删除元素使用remove方法，参数写入要删除的元素的值 Characters.remove(\u0026#39;b\u0026#39;) # 方法sort可以永久性地修改列表元素的排列顺序，初始是从小到大 Characters.sort() print(Characters) Characters.sort(reverse=True) # 颠倒排列顺序 print(Characters) cars = [\u0026#34;bmw\u0026#34;, \u0026#34;audi\u0026#34;, \u0026#34;toyota\u0026#34;, \u0026#34;subaru\u0026#34;] # 函数sorted()可以让你能够按照特定的顺序暂时显示列表元素，同时不影响它们在列表中的排列顺序 print(sorted(cars)) print(sorted(cars, reverse=True)) # 反转列表元素 cars.reverse() # 函数len()可以快速确定列表的长度 print(len(cars)) Marvel = [\u0026#34;IronMan\u0026#34;, \u0026#34;AntMan\u0026#34;, \u0026#34;CaptainAmerican\u0026#34;, \u0026#34;Hulk\u0026#34;, \u0026#34;Thor\u0026#34;] for i in Marvel: print(i) \u0026#34;\u0026#34;\u0026#34; 循环中，python依次从Marvel中取出一个变量，将其与变量i相关联，打印出来 在下面的循环中，range函数的范围实际上是1到10 \u0026#34;\u0026#34;\u0026#34; for item in range(1, 11): print(item) # 要创建数字列表，可以使用函数list()将range()的结果直接转换为列表 numbers = list(range(1, 11)) print(numbers) # 使用range()的第三个参数，通过指定步长来生成数，例如： even_numbers = list(range(1, 11, 2)) # 在这个示例中，函数range从1开始数然后不断+2，直到达到或超过最终值 print(even_numbers) # 下面的一个示例演示创建一个列表来包含1-10的平方 squares = [] for value in range(1, 11): squares.append(value ** 2) print(squares) digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(min(digits)) # 查找数字列表的最小值 print(max(digits)) # 查找数字列表的最大值 print(sum(digits)) # 计算数字列表的和 # 列表解析使得你只需编写一行代码就能生成这样的列表，这种技术将for循环和创建新元素的代码合并成一行并自动附加新元素 squares2 = [value ** 2 for value in range(1, 11)] # 该行代码以value作为迭代元素（从1到10），每次将迭代元素的平方作为列表元素的值 print(squares2) \u0026#34;\u0026#34;\u0026#34; 切片操作：可以通过指定使用的第一个元素和最后一个元素的索引，切片操作与range具有相类似的特征，如要 输出列表的前三个元素，则需要指定索引[0:3]，将返回索引0，1，2 [x:y]从第x位开始取，取y位 \u0026#34;\u0026#34;\u0026#34; squares3 = [(value*2+1) for value in range(1, 11)] print(squares3[0:3]) print(squares3[:4]) # 如果没有指定第一个索引，Python将从头开始 print(squares3[3:]) # 如果没有指定第二个索引，Python将提取到最后一个元素 print(squares3[-3:]) # 提取最后三个成员 # 遍历切片 for item in squares3[:3]: print(item) # 复制列表：创建一个包含整个列表的切片 copy_squares3 = squares3[:] print(copy_squares3) # python中，不可变的列表称为元组 created = (\u0026#39;a\u0026#39;, \u0026#39;b,\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;) print(created[0]) print(created[1]) # created[2]=\u0026#39;d\u0026#39; 该行为会报错 # 遍历元组的元素和列表操作相同 # 如要修改元组中的元素，需要重新定义整个元组 created = (\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;) # 创建只有一个元素的元组 created2 = (\u0026#39;a\u0026#39;, ) ","date":"2024-03-14T21:07:44+08:00","image":"http://localhost:1313/p/pythonbasic02/14_hud0ff8cb5dfde4b1c6ac322f6a5a0836f_349693_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic02/","title":"Python基础 02 列表"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 该程序中的各个方法并不会像函数一样对字符串产生实质性的变化 message = \u0026#34;hello\u0026#34; print(message) message = \u0026#34;Hello World\u0026#34; print(message) # Python是解释型语言，会逐行解释执行，因此对于变量python只记录变量的最新值 # 由于Python不检查变量名与上文的匹配，因此在变量命名中尽量不要用小写l和大写O，容易看错 # 字符串用双引号还是单引号都可以 print(\u0026#34;The language \u0026#39;python\u0026#39; is named after Monty Python, not the snake.\u0026#34;) name = \u0026#34;ada lovelace\u0026#34; print(name.title()) # 首字母大写 print(name.upper()) # 全大写 print(name.lower()) # 全小写 print(name) # 在字符串中插入变量的值，可以在前引号前加上字母f，再将要插入的变量放在花括号内 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; full_name = f\u0026#34;{first_name} {last_name}\u0026#34; print(f\u0026#34;Hello! {full_name.title()}!\u0026#34;) # 如果是python 3.5以及之前的版本，需要使用： # name = \u0026#34;{}{}\u0026#34;.format(first_name, last_name) name2 = name.rstrip() # 去右空白 name3 = name.lstrip() # 去左空白 name4 = name.strip() # 去空白 print(name) num1 = 3**3 num2 = 3**2 print(f\u0026#34;{num1} {num2}\u0026#34;) # python用**表示乘方运算，任意两个数相除时，结果总是浮点数 # 当定义很大的数的时候，可以使用下划线将数字分组，python不会打印这些下划线，如 num4 = 123_000_000_000 # python同时给多个变量赋值 x, y, z = 0, 0, 0 # python中没有常量，通常用全大写字母表示常量 ","date":"2024-03-14T21:07:16+08:00","image":"http://localhost:1313/p/pythonbasic01/12_hue96f00eb035c05652d604d3b67693450_240008_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/pythonbasic01/","title":"Python基础 01 字符串操作"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 与老师讨论新的项目方向 完成Stable Diffusion服务器搭建 √ 完成Qt翻金币项目UI设计 √ 给未央主机搭建内网穿透 √ 更新个人博客项目 √ 龙曲良深度学习教程完成手写数字识别项目 √ 精读一篇深度学习方向论文 本周个人提升内容 完成Stable Diffusion本地服务器搭建，并尝试文生图 完成Qt翻金币项目UI设计并初步掌握Qt Creator UI界面设计机制 机器学习项目完成回归类问题的求解 下周计划\u0026lt;按优先级排序高中次\u0026gt; 与老师讨论新的项目方向 完成Qt翻金币项目主界面机制设计 根据龙曲良深度学习教程学会Tensorflow基础语法 精读一篇深度学习方向论文 总结与反思 本周完成了计划的大部分内容，但是在实施计划过程中还是会有任务性思维所以感觉虽然完成了任务但是很多任务并没有感觉学到很多，准备下周在完成任务的基础上更多地以收获为导向而不是以任务目标为导向，争取能够有更多的输出。\n","date":"2024-03-10T21:56:08+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-03-10/6_hu5c903a671b8ba7b0eb81b9d1f9246689_210610_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-03-10/","title":"研究生周报 2024 03 10"},{"content":" 1 2 Ctrl + Ins 复制 Shift + Ins 粘贴 ","date":"2024-03-05T17:08:38+08:00","image":"http://localhost:1313/p/gitbash%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%BF%AB%E6%8D%B7%E9%94%AE/34_hu1fcfd80b17ed2a5f977b43a96e67bcb1_715245_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/gitbash%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"GitBash复制粘贴快捷键"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 每天学习至少十分钟粤语及英语 了解计算机视觉相关的光学原理 至少完成Qt翻金币项目的框架设计 完成项目初步方案设计并找老师讨论可行性 整理《认知觉醒》上的方法及思维模型 每天学习至少一节课深度学习课程 每天学习至少一节课51单片机 复习C++模板及刷题 博客优化 本周个人提升内容 与团队成员和老师讨论比赛选题及方向 完成每日粤语及英语打卡 了解光学侦测相关的光学原理 完成Qt翻金币项目的框架设计 下周计划\u0026lt;按优先级排序\u0026gt; 与老师讨论新的项目方向 完成Stable Diffusion服务器搭建 完成Qt翻金币项目UI设计 给未央主机搭建内网穿透 更新个人博客项目 龙曲良深度学习教程完成手写数字识别项目 精读一篇深度学习方向论文 总结与反思 本周在学习上略有懈怠\u0026hellip;感觉自身目标性还是不够强烈，在实验室玩电脑比较多，而且由于对竞赛项目方向选择的模糊性导致可行性分析报告一直拖到周五才勉强完成并和老师讨论方向。目前竞赛思路基本确定：\n1、从原定项目方向——电子导盲犬出发，增加限定条件及场景限制，尽可能找到一个确定的需求场景进行重点突破。\n2、更换方向，从突破人类身体极限进行考虑，例如需要高强度的重复工作、无氧环境、核污染环境、体型限制、力量限制等。从这些方面就比较容易找到相关的需求并且比较容易和军工联系起来。 下周在实施计划时，一定注意要及时分解目标并将每日自己需要完成的任务添加到手机待办事项中，否则还是容易陷入每天没有目的性的思维怪圈中。\n","date":"2024-03-04T21:53:46+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-03-04/36_hu1558120cca5f15bf48df30464e48bac8_4298276_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-03-04/","title":"研究生周报 2024 03 04"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 周一完成《认知觉醒》整本的阅读并整理读书笔记 周一周二制定机器人比赛的初步方案并和队友讨论 确定方案后询问老师们的意见并和老师们讨论研究方向 继续学习龙曲良深度学习课程（每日一课） 周天前完成第一个Qt小项目——翻金币（加入多线程计时模块） 根据自己感兴趣的研究方向查找相关论文进行阅读 继续优化博客并完成评论系统 复习C++模板及刷题 本周个人提升内容 完成《认知觉醒》的阅读 完成机器人创新设计大赛调研及初步方案的制订 查找计算机视觉以及大模型方向相关论文，对当前AI研究进展有了初步的了解 下周计划\u0026lt;按优先级排序高中次\u0026gt; 每天学习至少十分钟粤语及英语 了解计算机视觉相关的光学原理 至少完成Qt翻金币项目的框架设计 完成项目初步方案设计并找老师讨论可行性 整理《认知觉醒》上的方法及思维模型 每天学习至少一节课深度学习课程 每天学习至少一节课51单片机 复习C++模板及刷题 博客优化 总结与反思 在本周的工作中，我基本完成了《认知觉醒》的阅读并大致找到了竞赛项目的研究方向。通过对《认知觉醒》的阅读，我了解到了深度沉浸和关联学习的重要性——学习知识并不只是对技术或思想有一定的了解，而是通过学习构建自己的认知体系并能够通过联想将所学知识应用到不同领域。大部分人其实看起来很勤奋，把知识点全部背熟，但是并没有实际应用的能力，深究其因不过是通过肉体上的努力来掩盖思想上的懒惰罢了。我们在学习时不仅要了解知识，更要通过这层了解进行深度思考——这个知识点都可以用在哪些领域？此外，我们在学习时还要注重反馈的作用，这也是老师常说的为何让我们经常对自己所做的工作进行总结和反思，一方面我们会从总结中将所学知识进行拼接整合，通过审视自己所完成的工作而获得一定的多巴胺成就感，另一方面即是通过反思来改进自己当前的学习方法，以获得更加长足的进步。最后，还要注意目标和自身实力的适配性，不要定过高的目标（类似每天打卡要完成一个自己能力的上限），这样做其实很容易让自己的本能脑和情绪脑感到懈怠，为了完成任务而不看重知识的吸收质量，即使坚持下去也不一定收获很多，反而是每次给自己定较低的目标，在催动本能脑和情绪脑完成任务的同时又能让学习进度始终保持在自己舒适区的边缘，这样才能够保证自己在学习中始终能够保持沉浸，从而快速提升自己的实力。 在下周的工作中，我将尝试践行《认知觉醒》中的方法论来完成所定目标，并注重学习带来的反馈，不断更新自己的方法和工作习惯，希望能够获得更大的进步。\n","date":"2024-03-04T21:53:01+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-26/35_hu38b354471b543df6103c57dcfdcaffb2_3812188_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-26/","title":"研究生周报 2024 02 26"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 完成《认知觉醒》的阅读并在博客上更新读书笔记 完成Qt剩余部分的学习并更新学习笔记 完成VMware\u0026amp;Ubuntu环境搭建指南博客的编写 Hugo建站指南系列博客——Day2的编写 继续复习C++ STL模块和刷题 更新博客评论系统 本周个人提升内容 阅读《认知觉醒》后半部分内容并按书中方法施行计划 完成Qt剩余部分的学习并更新学习笔记 完成Hugo建站指南系列博客——Day2的编写 复习C++ STL，完成晴问顺序结构的题单 整理已搜集到的资料并准备搭建博客评论系统 下周计划\u0026lt;按优先级排序高中次\u0026gt; 周一完成《认知觉醒》整本的阅读并整理读书笔记 周一周二制定机器人比赛的初步方案并和队友讨论 确定方案后询问老师们的意见并和老师们讨论研究方向 继续学习龙曲良深度学习课程（每日一课） 周天前完成第一个Qt小项目——翻金币（加入多线程计时模块） 根据自己感兴趣的研究方向查找相关论文进行阅读 继续优化博客并完成评论系统 复习C++模板及刷题 总结与反思 本周，我继续阅读了《认知觉醒》并尝试实践书中的方法，包括通过细分目标来进行每周安排和使用元认知来进行自我管理等。过程中，我遇到了将大目标细化的困难，十分担心自己的步骤选择和努力方向的正确性。通过这次实践，我认识到了自我提升、通过积极执行来寻求反馈、实践小步骤以及定期回顾和调整计划的重要性，希望能够坚持下去，实现最终目标。\n","date":"2024-02-18T20:15:46+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-18/32_hu8af220edbd02810877d97f57345f0b88_892264_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-18/","title":"研究生周报 2024 02 18"},{"content":"Qt信号与槽机制 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。\n使用系统自带的信号和槽实现关闭窗口功能 首先需要创建一个按钮用于触发“关闭窗口”信号：\n1 QPushButton *btn = new QPushButton(\u0026#34;关闭窗口\u0026#34;, this); 然后我们可以通过connect函数进行信号的连接操作，connect函数的一般形式为：\n1 connect(sender, signal, receiver, slot); 参数解释：\nsender：发出信号的对象 signal：发送对象发出的信号（函数的地址） receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数（槽函数） 此处即体现出信号和槽机制松散耦合的优点：信号发送端和接收端本身没有关联，但可以通过connect进行连接将两端耦合在一起。 随后，填入相应实参即可调用connect函数进行信号连接。\n1 connect(btn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::close); 那么系统自带的信号和槽通常如何查找呢？这个就需要利用帮助文档了，比如这里我们需要的是QPushButton的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，但发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个\n1 2 3 4 5 6 void clicked(bool checked = false) void pressed() void released() void toggled(bool checked) - 3 signals inherited from QWidget - 2 signals inherited from QObiect 这里的clicked就是我们需要的signal函数，槽函数的寻找方式和信号一样，只不过他的关键字是slot。\n自定义信号与槽函数 定义两个继承自QObject的类——Teacher和Student，实现一个场景：上课铃响后，老师喊上课，学生们收到上课的信号回教室坐好。\nteacher.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #ifndef TEACHER_H #define TEACHER_H #include \u0026lt;QObject\u0026gt; class Teacher : public QObject { Q_OBJECT public: explicit Teacher(QObject *parent = nullptr); signals: // 自定义信号 写到signal下 // 返回值是void，只需要声明，不需要实现 // 可以有参数，可以发生重载 void ClassBegin(); public slots: // 自定义槽函数，写到slot下 }; #endif // TEACHER_H student.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #ifndef STUDENT_H #define STUDENT_H #include \u0026lt;QObject\u0026gt; class Student : public QObject { Q_OBJECT public: explicit Student(QObject *parent = nullptr); signals: public slots: // 早期Qt版本必须要写到public slots下，高级版本可以写到public或者全局下 // 返回值void，需要声明也需要实现 // 可以有参数，也可以发生重载 void SitDown(); }; #endif // STUDENT_H student.cpp 1 2 3 4 5 6 7 8 9 10 #include \u0026#34;student.h\u0026#34; #include \u0026lt;QDebug\u0026gt; Student::Student(QObject *parent) : QObject(parent) { } // 自定义成员函数记得加函数返回值类型 void Student::SitDown(){ qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好\u0026#34; \u0026lt;\u0026lt; endl; } widget.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #ifndef WIDGET_H #define WIDGET_H #include \u0026lt;QWidget\u0026gt; #include \u0026#34;teacher.h\u0026#34; #include \u0026#34;student.h\u0026#34; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private: Ui::Widget *ui; // 声明teacher和student类型成员变量 Teacher *tp; Student *sp; // 声明上课铃响函数 void Ring(); }; #endif // WIDGET_H widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;widget.h\u0026#34; #include \u0026#34;ui_widget.h\u0026#34; #include \u0026lt;QPushButton\u0026gt; Widget::Widget(QWidget *parent): QWidget(parent), ui(new Ui::Widget) { ui-\u0026gt;setupUi(this); QPushButton *btn = new QPushButton(\u0026#34;关闭窗口\u0026#34;, this); /* * 新建信号连接函数 * 参数1：信号发送者 * 参数2：发送的具体的信号（函数的地址） * 参数3：信号的接收者 * 参数4：信号的处理——槽函数地址（槽） * 信号和槽的优点——松散耦合：信号发送端和接收端本身没有关联，但可以通过connect进行连接将两端耦合在一起 */ // 参数2和参数4写父类子类都可以 connect(btn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::close); // 创建对象并指定父窗口 this-\u0026gt;tp = new Teacher(this); this-\u0026gt;sp = new Student(this); // 情景：上课铃响后，老师发出上课信号，学生响应信号，坐好 // 老师说上课，学生坐好的连接 connect(tp, \u0026amp;Teacher::ClassBegin, sp, \u0026amp;Student::SitDown); // 调用上课铃响函数 Ring(); } // 自定义的类方法记得加返回值类型 void Widget::Ring(){ // 上课函数，调用后触发老师喊上课的信号 emit tp-\u0026gt;ClassBegin(); } Widget::~Widget() { delete ui; } 此时的代码执行流程为：\n调用Ring()函数\u0026ndash;\u0026gt;触发老师喊上课信号\u0026ndash;\u0026gt;回调connect函数\u0026ndash;\u0026gt;学生收到信号\u0026ndash;\u0026gt;调用SitDown函数\n重载信号与槽函数 信号和槽函数均可发生重载\nstudent.h 1 void SitDown(QString ClassName); student.cpp 1 2 3 4 5 6 7 8 void Student::SitDown(QString ClassName){ // 直接使用此方式打印会使得ClassName带引号（QString类型字符串），需要转换为char*类型字符串 // qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好并拿出\u0026#34; \u0026lt;\u0026lt; ClassName \u0026lt;\u0026lt; \u0026#34;课本\u0026#34; \u0026lt;\u0026lt; endl; // QString -\u0026gt; char* 先转换成QByteArray再转成char* // 下面这种方式会多出一个空格 // qDebug() \u0026lt;\u0026lt; \u0026#34;学生都坐好并拿出\u0026#34; \u0026lt;\u0026lt; ClassName.toUtf8().data() \u0026lt;\u0026lt; \u0026#34;课本\u0026#34; \u0026lt;\u0026lt; endl; qDebug() \u0026lt;\u0026lt; (\u0026#34;学生都坐好并拿出\u0026#34; + ClassName + \u0026#34;课本\u0026#34;).toUtf8().data() \u0026lt;\u0026lt; endl; } teacher.h 1 void ClassBegin(QString ClassName); widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Widget::Widget(QWidget *parent): QWidget(parent), ui(new Ui::Widget) { ui-\u0026gt;setupUi(this); ... // 创建对象并指定父窗口 this-\u0026gt;tp = new Teacher(this); this-\u0026gt;sp = new Student(this); // 情景：上课铃响后，老师发出上课信号，学生响应信号，坐好 // 老师说上课，学生坐好的连接 // 当发生信号或槽函数重载后，connect无法分清是哪个函数发生了重载，需要通过函数指针重新指定函数地址 // connect(tp, \u0026amp;Teacher::ClassBegin, sp, \u0026amp;Student::SitDown); // 函数指针写法： // 函数返回值类型(命名空间:: *指针名)(参数类型1， 参数类型2...) = 函数地址 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 调用上课铃响函数 Ring(); } // 自定义的类方法记得加返回值类型 void Widget::Ring(){ // 上课函数，调用后触发老师喊上课的信号 // emit tp-\u0026gt;ClassBegin(); emit tp-\u0026gt;ClassBegin(\u0026#34;语文\u0026#34;); } 使用信号连接信号 程序情景：点击一个上课的按钮，再触发上课铃响，然后老师叫同学们坐好上课。\n1 2 3 4 5 6 7 8 9 10 11 // 通过函数指针重新指定有参函数的地址 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; // 通过函数指针重新指定无参函数的地址 void(Teacher:: *tsignal)(void) = \u0026amp;Teacher::ClassBegin; void(Student:: *ssignal)(void) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 使用按钮调用Ring函数 QPushButton *classbtn = new QPushButton(\u0026#34;上课\u0026#34;, this); classbtn-\u0026gt;move(100, 0); connect(classbtn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::Ring); 程序情景：点击上课的按钮直接触发老师喊上课信号，然后老师喊同学们坐好上课。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void(Teacher:: *teachersignal)(QString) = \u0026amp;Teacher::ClassBegin; void(Student:: *studentslot)(QString) = \u0026amp;Student::SitDown; // 通过函数指针重新指定无参函数的地址 void(Teacher:: *tsignal)(void) = \u0026amp;Teacher::ClassBegin; void(Student:: *ssignal)(void) = \u0026amp;Student::SitDown; connect(tp, teachersignal, sp, studentslot); // 使用按钮调用Ring函数 QPushButton *classbtn = new QPushButton(\u0026#34;上课\u0026#34;, this); classbtn-\u0026gt;move(100, 0); // connect(classbtn, \u0026amp;QPushButton::clicked, this, \u0026amp;Widget::Ring); // 使用按钮直接连接老师上课信号（有参），让老师上课信号作为槽函数再连接学生坐好的槽函数 connect(classbtn, \u0026amp;QPushButton::clicked, tp, tsignal); connect(tp, tsignal, sp, ssignal); 程序情景：点击上课按钮触发老师喊上课的信号，但学生不听老师的，不坐好\n1 2 // 使用disconnect函数断开连接 disconnect(tp, tsignal, sp, ssignal); Qt4版本信号和槽的写法 1 connect(zt,SIGNAL(ClassBegin(QString)),st,SLOT(SitDown(QString))); 这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到**connect()**函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。 Qt5在语法上完全兼容Qt4，而反之是不可以的。\nLambda表达式 Lambda是属于C++11的新特性。在早期版本(Qt4之前)需要在.pro文件中添加：CONFIG += c++11 C++中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。Lambda表达式的基本构成为：\n1 2 3 4 // 函数定义： [函数对象参数](操作符重载函数参数)mutable-\u0026gt;返回值类型{函数体} // 函数调用： (); 函数对象参数[]，标识一个Lambda的开始，必须存在。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：\n函数对象参数 解析 空 没有使用任何函数对象参数。 = 函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 this 函数体内可以使用Lambda所在类中的成员变量。若在connect函数中使用this时，前面的信号接收者(或信号发送者)可省略 a 将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。 \u0026amp;a 将a按引用进行传递。 a, \u0026amp;b 将a按值进行传递，b按引用进行传递。 =, \u0026amp;a, \u0026amp;b 除a和b按引用进行传递外，其他参数都按值进行传递。 \u0026amp;, a, b 除a和b按值进行传递外，其他参数都按引用进行传递。 操作符重载函数参数标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(\u0026amp;a,\u0026amp;b)）两种方式进行传递。\n可修改标示符即mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身，再次访问传入的函数对象参数时仍是原值）。\n1 2 3 4 5 6 7 8 9 10 QPushButton * myBtn = new QPushButton (this); QPushButton * myBtn2 = new QPushButton (this); myBtn2-\u0026gt;move(100,100); int m = 10; // 点击按钮输出110 connect(myBtn,\u0026amp;QPushButton::clicked,this,[m] ()mutable { m = 100 + 10; qDebug() \u0026lt;\u0026lt; m; }); // 点击按钮输出10 connect(myBtn2,\u0026amp;QPushButton::clicked,this,[=] () { qDebug() \u0026lt;\u0026lt; m; }); // 输出10 qDebug() \u0026lt;\u0026lt; m; 函数返回值-\u0026gt;返回值类型，标识函数返回值的类型。当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n函数体{}标识函数的实现，这部分不能省略，但函数体可以为空。\n使用Lambda表达式的优点： 在connect函数中使用Lambda表达式，可以更加方便地使用有参槽函数。\n信号和槽总结 信号可以连接信号 一个信号可以连接多个槽函数。如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号也可以连接同一个槽函数。只要任意一个信号发出，这个槽就会被调用。 信号和槽函数的参数类型必须一一对应 信号的参数个数可以多于槽函数的参数个数，但除了多出来的参数，剩下的参数类型仍然要一一对应。 信号槽可以通过disconnect函数断开连接 槽可以被取消链接。但这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 信号和槽函数返回值是 void 信号只需要声明，不需要实现 槽函数需要声明也需要实现 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 ","date":"2024-02-17T16:02:44+08:00","image":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_04/31_hu257b54557e64e568910f9552664481a3_2550935_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_04/","title":"QT学习记录_04"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 完成《认知觉醒》的阅读并在博客上更新读书笔记 完成Qt剩余部分的学习并更新学习笔记 完成VMware\u0026amp;Ubuntu环境搭建指南博客的编写 Hugo建站指南系列博客——Day2的编写 继续复习C++ STL模块和刷题 整理自己目标拆解的思路并应用到每日规划中 本周个人提升内容 完成《认知觉醒》前半部分内容的阅读 完成Qt信号与槽机制的学习笔记 下周计划 完成《认知觉醒》的阅读并在博客上更新读书笔记 完成Qt剩余部分的学习并更新学习笔记 完成VMware\u0026amp;Ubuntu环境搭建指南博客的编写 Hugo建站指南系列博客——Day2的编写 继续复习C++ STL模块和刷题 更新博客评论系统 总结与反思 本周\u0026hellip;由于考虑不周，在上周末制定计划时忘记考虑春节的因素，本周基本上在休闲娱乐中和家人度过，因此周计划并未按期望得到执行。希望可以将本周计划暂时推迟到下周执行，另祝老师春节快乐，龙年大吉！\n","date":"2024-02-17T16:02:15+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-11/29_huc3644c617b1047362e8c282841d9bafa_2238983_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-11/","title":"研究生周报 2024 02 11"},{"content":"创建Github Pages 要想把个人博客托管在Github Pages上，首先在GitHub上创建一个Repository，命名为：{your_username}.github.io比如我的仓库就叫codingxiaoma.github.io 如果你对你的username不满意，需要先在Setting-\u0026gt;Account-\u0026gt;Change username修改一个你满意的username。 注： Repository的前缀 (.github.io之前的内容) 一定要跟你的username保持一致。 仓库的权限需要选择Public, 否则无法访问。\n勾选Add a README.md，主要是为了自动创建main分支。\n然后在你的 仓库xx.github.io里面点击Settings, 左边的菜单栏找到Pages。 可以看到Your site is live at https://codingxiaoma.github.io/ 此时Github Pages就自动部署好了。点击Visit Site就可以看到你的网站了（因为我们的仓库是空的，所以网站也是空的）\nHugo站点和目标文件 现在我们有了Hugo个人站点，有了Github Pages，那么下一步就是把Hugo博客发布到github。这样我们才能在互联网的任何地方访问我们的博客。\n在我们本地的hugo根目录中执行hugo指令。会生成一个public文件夹，我们只需要把public的文件夹上传到Github上刚才创建的仓库里面, 一分钟左右，就能正常查看博客内容。\n这里解释一下：\nhugo站点（hugo根目录）：这个是源文件，也就是你写Markdown的地方，可以不用提交到github，也可以选择在github上创建一个新的repo，并提交。 public文件（hugo/public）：这个是目标文件，是使用hugo指令生成的发布HTML内容，可以在浏览器浏览的格式，需要推送到Github上然后发布到Github Pages静态网站上。 我们的hugo站点是源文件（带主题，图片，markdown源文件），public是目标文件（最终生成的css/js/html文件）。我们最终网页上展示的是目标文件，所以需要使用hugo指令生成目标文件。 发布博客到Github Pages 在任意hugo站点外（是为了以后把hugo源文件也上传到github，git是不能有层级的，所以要放在站点外）直接用git clone把创建好的github仓库克隆下来。\n1 git clone git@github.com:codingxiaoma/codingxiaoma.github.io.git 然后把public里面的所有内容复制到这个Git仓库(codingxiaoma.github.io)并执行：\n1 2 3 git add * git commit -m \u0026#34;first commit\u0026#34; git push 即可成功把内容push到远程仓库。\n复杂一点但是方便的办法为了不要每次改动都手动复制，我们可以创建一个public目录和github仓库的软链接。(需要先删除public目录)\n1 2 3 4 5 6 7 # 进入你的hugo根目录 # 删除public文件夹 rm -rf public # 前面是 github.io仓库的本地目录，后面是 public文件夹的本地​目录 ln -s /Users/hugo/codingxiaoma.github.io /Users/hugo/codingxiaoma/public 然后在hugo根目录下使用hugo指令，就会自动在public软链接也就是git repo下生成目标文件。 最终执行git add/commit/push之后，打开 https://codingxiaoma.github.io/ 就能看到博客内容。(可能有几分钟延迟，耐心等待)。 如果git push提示没有权限\n1 2 3 4 ERROR: Permission to left-pocket-test/left-pocket-test.github.io.git denied to left-pocket. fatal: Could not read from remote repository. Please make sure you have the correct access rights 说明还没有在Github上添加本机电脑的ssh key。 在本地生成ssh key：\n1 2 3 4 5 6 # 查看本地是否有已经生成的SSH密钥 ls -al ~/.ssh # 没有则重新创建SSH密钥 cd ~/.ssh ssh-keygen -t ed25519 -C \u0026#34;xxx@xxx.com\u0026#34; # 填写你的邮箱地址 然后一路Enter到底（如有需要可以键入默认文件位置和自定义安全密码）。\n然后就会在~/.ssh/目录生成默认的文件:\nid_rsa 私钥 id_rsa.pub 公钥 在新的管理提升终端窗口（PowerShell或CMD）中，确保ssh代理正在运行。可以使用“自动启动ssh代理”说明使用SSH密钥密码”，或手动启动它：\n1 2 3 # start the ssh-agent in the background Get-Service -Name ssh-agent | Set-Service -StartupType Manual Start-Service ssh-agent 在没有提升权限的终端窗口中，将SSH私钥添加到ssh代理中。如果使用不同的名称创建了密钥，或者如果正在添加具有不同名称的现有密钥，请将命令中的id_ed25519替换为私钥文件的名称。\n1 ssh-add C:\\Users\\YOU/.ssh/id_ed25519 之后把id_ed25519.pub也就是公钥的内容copy到github上即可。\n1 2 cat ~/.ssh/id_ed25519.pub 并复制 登录github，Settings-\u0026gt;SSH and GPG Keys-\u0026gt;add SSH Key. ","date":"2024-02-17T16:01:18+08:00","image":"http://localhost:1313/p/hugo-development-day2/30_hud2fc0782b828068ad19fdccc62bddd6d_475432_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/hugo-development-day2/","title":"Hugo建站指南——Day2"},{"content":"第一个Qt小程序 本篇开始即进入QT的开发环节，本节主要内容有QT PushButton的添加、QT 窗口编辑操作、QT 对象树及QT中的坐标系。\nQPushButton的创建 1. 查询assistant找到QPushButton的相关介绍 从图中说明我们可以看出，使用QPushButton需要包含头文件\u0026lt;QPushButton\u0026gt; ，同时需要widget模块的支持，由于我们使用的是QT5版本，因此QtCreator在项目构建时会自动包含widget模块（在使用QT4及以下版本时，需要在.pro文件中手动包含widget模块），而通过Inherits和Inherits By可得到QPushButton的继承路径：\n1 QObject -\u0026gt; QWidget -\u0026gt; QAbstractButton -\u0026gt; QPushButton -\u0026gt; QCommandLinkButton 2. 通过QPushButton类创建按钮并进行一系列初始化设置 打开mywidget.cpp（构建项目时自定义的类的源文件）并添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;mywidget.h\u0026#34; #include \u0026#34;ui_mywidget.h\u0026#34; // 按钮控件的头文件 #include\u0026lt;QPushButton\u0026gt; MyWidget::MyWidget(QWidget *parent): QWidget(parent), ui(new Ui::MyWidget) { ui-\u0026gt;setupUi(this); // 使用无参构造函数重新构建一个QPushButton对象并使btn指向该对象 QPushButton *btn = new QPushButton; // Question1: 添加的控件默认不会显示，需要调用show方法进行可视化，但为何生成的按钮并不依附于当前窗口内，而是重新打开一个窗口？ // btn-\u0026gt;show(); // 将当前窗口设置为父窗口，使得生成的按钮依附在当前窗口内部，并依赖父窗口的show方法显示按钮 btn-\u0026gt;setParent(this); // 设置并显示含文本的按钮 // Question2: 为什么我的中文显示乱码？ btn-\u0026gt;setText(\u0026#34;第一个按钮\u0026#34;); // 创建第二个按钮 // Question3: 为什么不能使用以下方法创建按钮对象？ // QPushButton btn2(\u0026#34;第二个按钮\u0026#34;,this); QPushButton *btn2 = new QPushButton(\u0026#34;第二个按钮\u0026#34;, this); // 移动btn2按钮 btn2-\u0026gt;move(100, 100); // 重置窗口大小 resize(600, 400); // 修改窗口标题 setWindowTitle(\u0026#34;这是一个窗口标题\u0026#34;); // 设置固定的窗口大小（防止用户使用鼠标拉伸窗口） setFixedSize(600, 400); // 设置按钮大小 btn2-\u0026gt;resize(100, 50); } MyWidget::~MyWidget() { delete ui; } 问题解答\nQuestion1： 由于当前新建按钮是基于一个新的Qt控件类——QPushButton，因此在调用show方法时调用的是QPushButton的show方法进行显示，在运行时会分别生成主窗口和按钮窗口（回顾main.cpp的内容）。因此我们在构建按钮时需要使用setParent方法为其指定父窗口，使其能够依附于主窗口进行显示。 Question2： 中文显示乱码是因为文件的默认编码不是utf-8，需要在上方菜单栏中选择工具-\u0026gt;选项-\u0026gt;文本编辑器-\u0026gt;Behavior找到文件编码，修改默认编码为utf-8后应用并确认即可 Question3： 在Qt中，对象模型一般基于动态内存分配而不是在栈上分配，即在创建对象时一般需要开发者在堆区为对象开辟内存空间，而不是将对象作为局部变量使用。这是因为局部变量存在于栈区，其生命周期在函数运行结束时截止，因此若使用QPushButton btn(\u0026ldquo;Text\u0026rdquo;, parent)的方法创建对象，那么该对象的生命周期仅仅是MiWidget构造函数的运行时间，当构造函数执行结束后，该对象也将会执行析构因此不会在运行时显示。而若使用new关键字在堆区创建对象，则其生命周期由开发者自行控制，在执行delete前该对象会一直存在。 对象树 从上文中我们可以看到，在创建控件对象时我们一般使用new关键字为新对象开辟内存空间，然而却并没有相对应的delete进行空间释放，这是因为Qt使用了对象树的技术使得程序运行结束后能够自行释放内存空间。\n对象树的定义： 当你创建一个QObject对象时，可以看到QObject的构造函数会接收一个QObject指针作为参数，这个参数就是parent（父对象指针）。由此，每当创建一个QObject对象时，Qt便会自动添加该对象到其父对象的children()列表，当父对象析构时，这个列表中的所有对象也会被析构。（注意：这里的父对象并不是继承意义上的父类，而是说该对象显示在（或依附于）哪个对象中。例如：一个按钮有一个QShortcut（快捷键）对象作为其子对象，当我们删除按钮时，这个快捷键也会被删除。 QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。当创建的对象在堆区时，如果指定的父对象所属类是QObject派生下来的类或其子类，那么派生下来的类可以无需管理释放操作，会将对象放入对象树，一定程度上简化了内存回收机制。 Qt中的坐标系 左上角为(0, 0)点 x以右为正方向，y以下为正方向，坐标向右向下逐渐增大 对于嵌套窗口，其坐标是相对于父窗口来说的(即坐标原点总是位于父窗口左上角) ","date":"2024-02-04T20:52:02+08:00","image":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_03/22_hu8c3a5b5f054fe6608239643744ee4034_521651_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_03/","title":"QT学习记录_03"},{"content":"Qt项目构建及项目结构说明 Qt Creator窗口介绍 欢迎界面 Projects：主要功能为管理会话、创建项目、打开项目 示例：可下载并参考一些官方做的Qt项目 教程：官方的Qt教程，需要翻墙观看 MarketPlace：一些可下载的Qt工具包 编辑界面：编辑当前项目代码 设计界面：通过可视化操作编辑当前界面UI Debug界面：代码调试 项目界面：设置并查看当前项目的一些配置信息 帮助界面：极为重要的界面，可以使用Filter学习自己不熟悉的类 Qt项目构建流程 欢迎界面的Projects模块点击New新建项目 在本次学习中，我们只涉及到Qt窗口应用的构建及开发，选择Application(Qt)-\u0026gt;Qt Widgets Application点击Choose 选择要创建项目的存储路径并输入项目名称，该步骤完成后会在存储路径生成两个目录，一个用于存放源文件，另一个用于存放构建及调试文件。（后续会讲解如何将这两个目录合并到一起） 选择项目的构建系统，在该步骤中，Qbs一般不会考虑，剩余两项构建系统的区别为：\nqmake：是Qt内置的构建系统，十分地简单方便，但扩展性和功能相对较低，初学阶段或小型项目选择qmake点击下一步即可。\ncmake：相对复杂，但扩展性和功能更加强大，适用于复杂度超过qmake处理能力的项目。 设置自己的窗口类，并勾选是否使用设计界面编辑窗口，其中类名可以自由指定，QWidget是QMainWindow和QDialog的父类。 QWidget是最简单的交互窗口，QMainWindow除了窗口外多了菜单栏、状态栏等等，QDialog是对话框（包含确认按钮、取消按钮等，类比当前窗口） 选中Generate form后会启用设计界面。指定类名后，下面的基类名、头文件、源文件等会自动跟随自定义类名进行命名。配置完成后点击下一步。 选择是否为Qt项目添加英文自动翻译工具，一般不需要因此暂时忽略。 选择构建项目所使用的编译环境，我是64位机因此选择第二个选项，如要获得更多的系统可移植性可选择32位进行项目构建。 完成项目构建，从要添加的文件中可了解到项目的构建路径以及项目所包含的项目文件。\nmain.cpp是主程序入口\nmywidget.cpp是个人定制的窗口类\nmywidget.h是个人定制的窗口类的头文件\nmywidget.ui是个人定制的窗口类的可视化设计文件，它本质上是一个标准XML格式的文本，需要通过uic工具将其转换为项目中可用的ui_*.h头文件，使用时ui是一个指向自定义界面类的指针（后面一般跟着控件名）例如ui文件中有一个叫textEdit的QTextEdit组件，你就可以通过ui-\u0026gt;textEdit来访问这个文本框\nQtStudy_Day01.pro是工程文件，是qmake(or cmake)自动生成的用于生成makefile的配置文件，可以通过该文件直接打开项目。\n基础main函数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 自己新建的窗口类 #include \u0026#34;mywidget.h\u0026#34; // 包含一个应用程序类的头文件 #include \u0026lt;QApplication\u0026gt; // main函数主要执行一些初始化的工作，然后将控制权转交给Qt库，然后Qt库通过事件向程序告知用户行为。 // 程序入口，argc用来接收命令行参数的个数，argv用来接收命令行参数的数组 int main(int argc, char *argv[]) { // a是应用程序类QApplication实例化出来的对象，每个Qt程序有且仅有一个 QApplication a(argc, argv); // 使用自定义的窗口类MyWidget构建一个窗口对象w，MyWidget是继承自父类QWidget的子类 MyWidget w; // 构建窗口对象w后默认不会显示窗口，必须调用show方法进行显示 w.show(); // 让应用程序对象进入消息循环，即main函数将控制权转交给Qt // 在exec()函数中，Qt接收处理用户和系统的事件并将它们传递给适当的窗口部件 return a.exec(); /* 类比: while(true){ if(点击叉号) break; else{ 捕获动作 continue; } } */ } .pro文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 一般情况下不要轻易改动.pro文件 # Qt包含的模块：core和gui（Qt5以上才将Qt Widget模块从gui模块分离出来） QT += core gui # Qt版本号大于4，Qt新增了Widget模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets # 工程配置和编译的参数，允许C++11语法 CONFIG += c++11 # 项目编译后生成的可执行文件的文件名（可修改），在项目调试目录中 TARGET = QtStudy_Day01 # 使用Qt的application模板，告诉qmake为这个应用程序生成哪种makefile TEMPLATE = app # 预定义预处理符号 DEFINES += QT_DEPRECATED_WARNINGS # 指定来自moc的所有中间文件放置的目录（含Q_OBJECT宏的头文件转换为标准.h文件的存放目录） MOC_DIR += \\ # 指定多有中间文件.o(.obj)放置的目录 OBJECTS_DIR += \\ # UIC将ui转化为头文件所存放的目录 UI_DIR += \\ # 指定编译项目时应该搜索的文件夹 INCLUDEPATH += \\ # 指定最终文件生成的目录 DESTDIR += \\ # You can make your code fail to compile if it uses deprecated APIs. # In order to do so, uncomment the following line. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 # 源文件包含main.cpp以及mywidget.cpp文件 SOURCES += \\ main.cpp \\ mywidget.cpp # 头文件包含mywidget.h文件 HEADERS += \\ mywidget.h # 设计文件包含mywidget.ui文件 FORMS += \\ mywidget.ui # Default rules for deployment. # 目标文件地址 qnx: target.path = /tmp/$${TARGET}/bin else: unix:!android: target.path = /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS += target 自定义窗口头文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 防止头文件被重复引用，如果没有该自定义头文件则执行#define MYWIDGET_H进行头文件包含操作。 #ifndef MYWIDGET_H #define MYWIDGET_H // 包含窗口类头文件 #include \u0026lt;QWidget\u0026gt; // 定义自定义窗口类的命名空间Ui，声明Ui命名空间下的Widget类 QT_BEGIN_NAMESPACE namespace Ui { class MyWidget; } QT_END_NAMESPACE // 让自定义窗口类继承QWidget类以使用show等方法 class MyWidget : public QWidget { // 宏，允许类中使用信号和槽的机制以及元对象系统服务，必须限定为私有访问权限 Q_OBJECT public: // 声明有参构造函数并提供默认值，使用该默认值时将调用父类QWidget的有参构造函数 MyWidget(QWidget *parent = nullptr); // 声明默认析构函数 ~MyWidget(); private: // 创建Ui::Widget类型的指针，用于操作ui界面及其控件。 Ui::MyWidget *ui; }; #endif // MYWIDGET_H 自定义窗口源文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;mywidget.h\u0026#34; #include \u0026#34;ui_mywidget.h\u0026#34; // 有参构造函数的定义：声明时使用了默认参数，定义时则不再使用 /* * MyWidget有参构造函数的定义，并使用初始化列表对其进行初始化： * 已知MyWidget继承自QWidget，令QWidget *parent = parent，然后对MyWidget进行初始化。 * 令ui = new Ui::MyWidget，使得ui指针指向新创建的Ui命名空间内的MyWidget类型对象，通过这个对象可以访问和操作MyWidget的用户界面元素。 */ MyWidget::MyWidget(QWidget *parent): QWidget(parent), ui(new Ui::MyWidget) { // 为ui对象传入当前窗口对象指针，将当前窗口对象与其ui绑定 ui-\u0026gt;setupUi(this); } // 析构函数的定义 MyWidget::~MyWidget() { delete ui; } Qt Creator快捷键 Key 说明 ctrl + / 注释 ctrl + r 运行 ctrl + b 编译 ctrl + MouseUp/MouseDown 字体缩放 ctrl + f 查找 ctrl + shift + ↑/↓ 整行移动 F1 帮助文档（或者直接运行Qt Assistant） ctrl + i 自动对齐 F4 同名之间 .h和 .cpp自由切换 ","date":"2024-02-04T20:51:56+08:00","image":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_02/20_hue8028801c9f73dd91eba9fc177c5fd74_708628_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_02/","title":"QT学习记录_02"},{"content":"QT概述 QT简介：跨平台C++图形用户界面应用程序框架，完全面向对象，易扩展且允许组件编程。 版本及兼容性： QT商业版：相较开源版本多提供了商业有效期内的免费升级和技术支持服务。 QT开源：与商业版相同功能，在GNU通用公共许可下发布的免费版本。 Windows全平台、Linux、Mac全平台、嵌入式Linux、iOS、Android、WP QT入门资源推荐 QT入门到进阶书籍（建议从Qt5开始学） 《QT Creator 快速入门 霍亚飞》：必买 《QT及QT Quick开发实战精解》：5个实用的QT实例以及QT Quick技术介绍 《Qt5.9 C++开发指南》：必买 《Qt5开发及实例》：以QT5作为平台，每个章节用一个小实例介绍QT5开发的各个方面，最后通过三个大实例系统介绍QT5综合应用开发。 《QT5编程入门》：qml推荐书籍 进阶 《C++ GUI QT4编程》 《QT高级编程》 OpenCV3和Qt5计算机视觉应用开发 推荐的QT论坛+个人博客+网站 名称 网址 qtcn http://www.qtcn.org 豆子的空间 [DevBean Tech World](DevBean Tech World) yafeilinux qt qml linux 嵌入式 教程! 一去二三里 http://blog.csdn.net/liang19890820 乌托邦2号 http://blog.csdn.net/taiyang1987912 foruok http://blog.csdn.net/foruok jason http://blog.csdn.net/wsj18808050 朝十晚八 [朝十晚八 - 博客园](朝十晚八 - 博客园) BIG_C_GOD http://blog.csdn.net/big_c_god 公孙二狗 https://qtdebug.com/qtbook 雨田哥 https://blog.csdn.net/ly305750665 郑天佐 https://blog.csdn.net/zhengtianzuo06 寒山-居士 https://blog.csdn.net/esonpo feiyangqingyun https://blog.csdn.net/feiyangqingyun 前行中小猪 http://blog.csdn.net/goforwardtostep 涛哥的知乎专栏 Qt进阶之路 Qt君 https://blog.csdn.net/nicai_xiaoqinxi Qt老外视频教程 [哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili](哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili) Qt维基补充文档 Qt Wiki Qt源码查看网站 qt5/ Source Tree - Woboq Code Browser Qt官方下载地址 Index of / Qt国内镜像下载地址 [Index of /qt/](Index of /qt/) Qt优点 跨平台 接口简单 一定程度上简化了内存回收程序 Qt成功案例 Linux的一种桌面环境：KDE WPS Office Skype 网络电话 Google Earth 谷歌地图 VLC 多媒体播放器 VirtualBox虚拟机软件 Qt版本 商业版 为商业发行版Qt，并且提供商业有效期内的免费升级和技术支持服务 开源LGPL版本 提供了与商业版本同样的功能，但没有免费升级和技术支持服务 ","date":"2024-02-04T20:51:42+08:00","image":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_01/19_hu279ce5e96b74c838a255ccc4e759ad22_706904_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95_01/","title":"QT学习记录_01"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 每日英语、粤语学习 完成Qt基础，了解信号及槽的机制 学习龙曲良深度学习课程 复习C++ STL部分，开始刷题 如有空余时间，继续51单片机的学习 本周个人提升内容 完成Qt信号与槽机制的复习，学习记录更新完Qt基础部分 由于个人惰性，未分出多余时间继续深度学习课程，转而阅读周岭的《认知觉醒》且受益良多 完成C++ STL vector和string容器的复习，继续PTA刷题之旅，目前天梯赛卡在第9题还是无法通过\u0026hellip; 了解原神内存扫描技术实现机理，搜索MOD并使用3dmigoto库更换游戏人物及武器模型 完成个人博客基础阶段的复现，再次导入GitHub Pages实现外部访问 周累计完成5篇博文的写作 下周计划 完成《认知觉醒》的阅读并在博客上更新读书笔记 完成Qt剩余部分的学习并更新学习笔记 完成VMware\u0026amp;Ubuntu环境搭建指南博客的编写 Hugo建站指南系列博客——Day2的编写 继续复习C++ STL模块和刷题 整理自己目标拆解的思路并应用到每日规划中 总结与反思 相较于前几周，从工作完成度上来说本周的成果还是略有进步的。首先在个人提升方面，我通过《认知觉醒》这本书的确了解到了很多十分震撼的大脑运行机制，开始了解大脑的组成以及所谓毅力、耐心、学习力的底层原理——即理智脑与本能脑和情绪脑的完美合作才是一个人能够拥有这些品质的根本原因。解读此书前半部分后，回头再看老师曾给出的建议会有更大的感悟——要想持续获得进步，不是只靠个人“毅力”就行，而是要有一个明确合理的目标，并且要对目标进行深度的拆解，拆解成一个个切实可执行的步骤，才会让自己的本能脑和情绪脑获得安全感，自愿协助理智脑向着目标一步步前进，同时在努力过程中也要动用理智脑对当前工作进行评估，切莫不可让本能脑盲目努力，偏离方向是大忌！！！因此，从下周开始我要明确我的目标并进行详细拆解，并将步骤分配到每日规划中，不再是向前几周一样最后记周报，而是每天都要对周报进行更新。希望在下一周的学习中能够好好地巩固基础，为下学期的课题学习和论文阅读打下坚实基础！\n下附更新后的个人博客地址，下周更新评论系统，希望老师多多指正(^▽^) 木木龙的个人博客\n","date":"2024-02-04T20:47:08+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-04/17_hub468cb9e2e0fb22530e23a0e0293acef_781019_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-02-04/","title":"研究生周报 2024 02 04"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 完成LabWindows的学习并使用LabWindows复现C多线程时钟项目 学习龙曲良深度学习教程 阅读《流畅的Python》 本周个人提升内容 复习C++面向对象编程部分 学习串口通信、虚拟串口的相关知识，学会利用串口助手进行不同串口间的数据通信 继续Qt学习 阅读《流畅的Python》，开始复习Python 学习龙曲良深度学习课程 下周计划 每日英语、粤语学习 完成Qt基础，了解信号及槽的机制 学习龙曲良深度学习课程 复习C++ STL部分，开始刷题 如有空余时间，继续51单片机的学习 总结与反思 本周时间还是主要分配到了工作方面，周一至周二在部队协助任总和陈靖老师修改邢老师军工项目的研制总要求、经济分析报告等7个文件，虽然没有学到什么技术方面的知识，但能与任总、陈老师一起交流工作、学习、个人提升等方面的经验的确受益匪浅，同时让我了解了实体项目开发的完整流程，当全功率运转两天完成所有项目文件的修改时，内心犹然升起的成就感还是能够让人感到满足的。周三周四基本都在收拾虚拟机的时间中度过，踩了十几次坑总算是搞懂了VMware共享文件夹的配置机制——虚拟挂载点的挂载，准备专门写一篇博客记录这次艰难的环境配置过程。本想从周三开始专心学习专业知识，但是仍然无法静下心来进入心流状态——学习时要仔细感知手机的震动幅度，不敢错过刘“老师”的“社会经验上的锻炼”。好在近几日小团队确立了比赛的大致方向，且龚老师给我们讲解了串口通信和虚拟串口的相关知识，最终明确了暑假努力的大致方向——C++(主攻Qt和控制)、Python（主攻AI），希望在寒假能够好好利用起来，加油！\n","date":"2024-02-04T20:46:54+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-28/15_hua9639fdd76374f00e733dda3b2a0aac6_206055_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-28/","title":"研究生周报 2024 01 28"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 尝试重新拉回既定的项目计划及周计划-\u0026gt;在个人提升方面重新步入英语、粤语、深度学习、硬件编程上的学习，争取在原定目标日完成要求的学习任务及项目任务。\n每日英语单词打卡 每日口语打卡 每日粤语打卡 在个人主机搭建好深度学习开发环境 测试《机器学习的数学》中的代码 完成龙曲良《深度学习》课程基础部分 每日算法题 重启个人博客项目 学习Qt 本周个人提升内容 每日打卡 搭建Tensor flow深度学习开发环境 复习Python基础并测试机器学习代码 重启个人博客项目 总结Ubuntu系统初始化步骤 学习C多线程库并复现示例代码 下周计划 完成LabWindows的学习并使用LabWindows复现C多线程时钟项目 学习龙曲良深度学习教程 阅读《流畅的Python》 总结与反思 也许是自己没有做好时间规划的原因，总感觉没有什么时间做自己的事情。本周时间分配为（周一周二去给邢老师帮忙改文件，周三给刘老师改论文，给邢老师做PPT，周四接着去华山出差交付材料，周五休息一天后，周六周天除每天改一点PPT、给刘老师找期刊外，剩余的学习时间还是较为充足的）但是由于个人懒惰、自制力差等原因，每天仍无法早起早睡，因此浪费较多时间。下周要多从个人生活习惯上抓起，养成早睡早起、睡前不看手机的习惯，注重碎片化时间的管理。 由于下周一开始连续两三天出差，且出差后要参与查找期刊以及整理论文的工作。因此未安排过多计划，望个人能够注重时间及精力管理，合理安排个人时间提升自己。\n","date":"2024-02-04T20:46:48+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-21/5_huacaf5c8865a77222a35a7e533953dfb1_799811_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-21/","title":"研究生周报 2024 01 21"},{"content":"摘要 该文档主要描述本周主要活动内容及收获，之后主要论述下周个人计划及其被安排在此时间节点的原因。\n本周个人提升计划 1 由于个人惰性以及易受外界环境干扰的性格，导致本周几乎没有任何有规律且十分合理的每日或每周计划，且距离曾经制定的每周及每月目标相去甚远，距离曾经制定的项目计划相去甚远，每天感觉被各种琐事缠身却又无法获得任何实际性的收获。以下将列出本周所做的一些工作安排和一些小习惯的安排。 查询打印机的分类、原理及各型号、品牌的区别和定价，为爷爷找到适合家用且产生有害物对肺部危害最小的打印机品型 完成Kali Linux定制项目，并编写项目报告 查询计算机系统硬件的相关知识，向王崭师兄打听实验室4090的问题并寻找解决办法 完成院公众号关于于老师课题组宣传推文的编写 总结上周末与小队成员共同查询的各种人工智能\u0026amp;电子设计竞赛的相关信息并反映给邢老师 给刘老师查期刊 本周个人提升内容 [最大收获] 听龚老师讲解关于认知与思维模式相关的内容，从而产生共鸣并开始反思自己当前各种行为方式、生活作息等与既定目标和计划的联系与差距，学会戒断多巴胺上瘾的小技巧并尝试应用。 了解了打印机的分类以及各类打印机的工作模式、机制原理及其会产生的有害物质（臭氧、VOC2、PM2.5） 激光打印机 喷墨式打印机 热敏打印机 了解了当前各类打印机的主流技术及选购方法 了解了计算机系统主板、CPU、显卡（GPU）、电源、内存、硬盘的相互关系并与其他同学合作组装主机 了解LabWindows基本开发方式 根据实验室一体化驱动项目了解硬件设计项目的组成和项目开发原理 下周计划 尝试重新拉回既定的项目计划及周计划-\u0026gt;在个人提升方面重新步入英语、粤语、深度学习、硬件编程上的学习，争取在原定目标日完成要求的学习任务及项目任务。\n每日英语单词打卡 每日口语打卡 每日粤语打卡 在个人主机搭建好深度学习开发环境 测试《机器学习的数学》中的代码 完成龙曲良《深度学习》课程基础部分 每日算法题 重启个人博客项目 学习Qt 总结与反思 本周几乎未有计划有目标地完成任何一件事，这样是不行的！还是要每天进行总结，进行反思，一定要有一个强烈的总目标并进行拆解，时刻注意停下脚步回头看一看，否则将可能离自己的目标越走越远！此外，这周周报还交晚了\u0026hellip;反思反思。\n","date":"2024-02-04T20:46:36+08:00","image":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-14/4_hu3b8c4ec53e3fd0f517d4e8188a63723a_4425471_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/postgraduate-weekly-report-2024-01-14/","title":"研究生周报 2024 01 14"},{"content":"写在前面 大学期间曾经尝试了许多中博客框架，从最初的WordPress到后来的Hexo再到使用Django搭建包含管理员后台系统的完整博客网站，但都没能够长时间使用，总感觉从前期开发到后期部署会出现各种各样的问题。于是我一直想要寻找一个能够快速构建、方便部署并能够让我在更新过程中不断对其进行完善的博客框架；直到Git Pages的出现，让静态网站框架搭建博客有了无与伦比的优势，我也开始搜集各种教程搭建博客，并最终确定了Hugo这一优秀的框架。\n本篇文章作为Hugo建站的系列文章，将详细记录我在建站过程中的建站流程、遇到的困难以及解决方法，希望能给读者朋友们带来一定的帮助。\n注：我是在Ubuntu 20.04环境下搭建的，在一些细节方面不同系统可能存在一些差异，见谅。\n准备阶段 由于Hugo是基于Go语言开发的静态网页框架，并且需要我们部署到Github上来允许其他人的访问，因此我推荐你预先安装以下三款软件。\n1 2 3 1. Go # 为Hugo提供更多的Go语言支持 2. Git # 实现与Github的远程拉取及推送服务 3. DartSass # 实现Hugo中Sass语法与css语法的转换 Go Linux 删除旧版本的Go，一般是在 /usr/local/go 中，然后下载官方的tar包并解压到 /usr/local 中: 1 $ rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.21.6.linux-amd64.tar.gz 以上指令可能需要管理员身份或添加sudo语句来执行，记住不要将文件解压到一个已经存在的go目录，可能会导致Go无法正常运行。\n将 /usr/local/go/bin 添加到环境变量中（将以下语句写入 $HOME/.profile 或者 /etc/profile ） 1 export PATH=$PATH:/usr/local/go/bin 添加该行语句并保存退出后记得使用source指令更新系统环境变量\n在命令行中输入以下语句来检验go的安装及版本号 1 $ go version Windows 下载好相应的MSI文件后根据提示依次执行安装程序 重新打开命令行输入 go version 验证安装。 Git Linux(System Based on Debian) 1 sudo apt install git-all Windows 1 直接按照官网提示进行安装即可。 DartSass Linux(System Based on Debian) 进入Dart-Sass Release下载相应的安装包 解压到 /usr/local 中 1 sudo tar -zxvf ~/Downloads/dart-sass-1.52.1-linux-x64.tar.gz -C /usr/local 以上指令可能需要管理员身份或添加sudo语句来执行，记住不要将文件解压到一个已经存在的dart-sass目录，可能会导致Dart无法正常运行。\n将 /usr/local/dart-sass 添加到环境变量中（将以下语句写入 $HOME/.profile 或者 /etc/profile ） 1 export PATH=$PATH:/usr/local/dart-sass 添加该行语句并保存退出后记得使用 source 指令更新系统环境变量\n在命令行中输入以下语句来检验go的安装及版本号 1 $ sass --version 安装Hugo 进入Hugo Release的下载页面，下载对应的Hugo-extended版本的deb包(注意！！！一定要安装hugo-extended版本，否则有些主题会出现不支持的问题) 输入以下命令进行安装和验证 1 2 sudo dpkg -i 你的安装包的名字.deb hugo version 若命令行中出现extended字样，说明Hugo已被正确安装。\n使用Hugo新建站点并引入主题 首先需要创建一个新的个人站点 1 hugo new site blog blog就是博客站点所在的目录，即站点根目录，创建后站点目录结构如下： 1 2 3 4 5 6 7 8 9 10 11 archetypes assets content data i18n layouts public resources static themes config.toml 简单介绍下Hugo根目录下各个文件目录的作用： archetypes 存放创建文件时使用的模板，可以自定义front matter属性。 assets 存放需要被Hugo Pipes处理的文件，且只有使用了.Permalink或者.RelPermalink的文件才能被发布到public目录。 注意，默认不会创建assets目录。 content 存放的各种md文件用于部署站点，该目录下可以自行创建若干个子目录来便于对文章进行分类，这些子目录被称为section。 data 目录存放的是用于定义变量的模板文件，相当于Java里的常量类，这些文件有JSON、 YAML或者TOML三种格式，会在生成站点时被使用到。一般用不到该功能，具体用法可以参考：data templates i18n 存放博客所需的各种语言包 layouts 目录存放的模板文件用于渲染html页面，模板里可以定义不同页面的html代码。 public 目录用于存放站点执行hugo -D指令后生成的静态页面文件，提交时只需将此目录中的文件推送到远程库中即可 resources 目录用于缓存某些文件来提高生成效率。 注意，默认不会创建resources目录。 static 目录存放的是静态内容：图片、CSS、JavaScript等。 themes 目录用于存放Hugo支持的主题文件 config.toml 是配置文件，可以有JSON、 YAML或者TOML三种格式，默认使用根目录下的config.toml、config.yaml或config.json中的某一个。可以通过\u0026ndash;config来配置读取一个或多个配置文件，如：hugo \u0026ndash;config a.toml,b.toml,c.toml。 注意，默认不会创建config目录。 进入站点目录，下载主题到站点theme文件夹的相应主题目录下： 1 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 进入themes/hugo-theme-stack/exampleSite目录，复制所有内容到站点目录并进行替换： 1 2 cd themes/hugo-theme-stack/exampleSite sudo cp * ../../../ 切换到站点目录，使用如下指令即可新建博文并且在本地运行博客网站： 1 2 3 hugo new post/我的第一篇博客 hugo -D hugo server -D 注：新建博文后博文头部front matter中draft: true表明该文章是草稿，如果在启用服务时不指定参数-D或\u0026ndash;buildDrafts，或者在配置文件config.toml中配置buildDrafts = true，则会在生成文章时忽略草稿。如果不想指定该参数就生成文章，需要改为draft: false或者将其删去！！！ 另注：新建博文后front matter中一定记着填写一个独一无二的标签，不是为了方便自己阅读，而是能够保证Hugo在生成静态页面文件时不至于将多篇博文错认成一篇博文从而导致一篇博文多次发表的情况！！！\n总结 以上就是Hugo搭建Stack主题博客的基础部分，下期将会讲解如何将个人博客推送到GitPages以允许博客的外部访问。\n","date":"2024-02-02T15:19:35+08:00","image":"http://localhost:1313/p/hugo-development-day1/82_hub28da18d4871e87a3433ed7bebc8e373_795065_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/hugo-development-day1/","title":"Hugo建站指南——Day1"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","image":"http://localhost:1313/p/math-typesetting/87_hu1c805f75d7d3cbd4969b0834385286cd_320605_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]